
강사명: 인경열
이메일: inky4832@daum.net


1. 회원가입
 
  - 구글
  - github
  - 오라클
    http://www.oracle.com

2. 환경설정

  1) JDK ( Java Development Kit ) 설치
    - C:\Program Files\Java\jdk-17 에 기본적으로 설치됨.
    - 환경변수 설정
      시작 > 마우스 오른쪽 클릭 > 시스템 > 고급 시스템 설정 > 고급 탭 > 환경변수 

      JAVA_HOME=C:\Program Files\Java\jdk-17  <=== JDK의 홈디렉터리 경로 설정
      PATH=%JAVA_HOME%\bin;기본PATH                                   <=== 윈도우의 프로그램에 명령어 경로 설정
           C:\Program Files\Java\jdk-17\bin;기본PATH   

      * 주요 명령어 2개

       javac.exe ( 컴파일하는 명령어, 컴파일러(compiler) 라고 부름 )

       java.exe  ( 실행하는 명령어,  인터프리터(interpreter) 라고 부름 )


      * 자바 실행 순서

      소스 파일( *.java 예> Test.java )
         |
      컴파일 작업 ( 컴파일러 이용: javac.exe )
                
		문법:  javac Test.java  <=== Test.class 파일이 생성됨 

         |
      실행 작업 ( 인터프리터 이용: java.exe )

                문법:  java Test        <=== Test 클래스가 실행되어 결과가 나옴.


      * JDK 설치시 설치되는 JVM ( Java Virtual Machine )


         *.class
        -------------
         JVM 
        --------------
          OS ( Window, Linux, Mac )
         -------
	   H/W
   
       JDK ( Java Development Kit     : 자바개발 환경 ) <==== 실제로 자바어플리케이션 개발하는 개발자 환경
                                                          JRE +  API + 개발도구( javac, ... ) 

       JRE ( Java RunTime Environment : 자바실행 환경 ) <==== 실제로 자바어플리케이션을 실행하는 일반 사용자 환경.
                                                          JVM + API

       자바 API : 자바에서 미리 만들어서 제공된 클래스 파일들을 의미.
                압축해서 제공됨. ( *.jar 형식 )
             
	       C:\Program Files\Java\jdk-17\lib\src.zip 파일이 API의 소스파일.

             * 자바의 압축 파일 3가지
  
               -jar
	         => 일반적인 SE 환경의 압축파일
                    예> *.jar
	       -war
	         => 일반적인 EE 환경의 압축파일
                    예> *.war
	       -ear
                 => jar + war 환경의 압축파일
                    예> *.ear

      자바 API 문서 :  어떤 자바 API가 있는지 알려주는 메뉴얼.
                    웹으로 제공됨.
           https://docs.oracle.com/en/java/javase/17/docs/api/index.html



   2) 개발툴 ( IDE )
     - 인텔리제이 (
       http://www.jetbrains.com

     - 이클립스
       http://www.eclipse.org
       인스톨 프로그램 아님. 압축 풀면 설치됨.
       C:\java_study\eclipse\workspace 생성  > eclipse.exe 실행
       
       eclipse 실행후 추가작업
        가. 한글 인코딩 설정 (utf-8)
           elcipse의 window항목 > preference > General > workspace 에서 Text File Encoding 에서
	   UTF-8로 설정.

	나. 글꼴 설정
	   elcipse의 window항목 > preference > General > Apper~ > Color&Fonts > Basic > Text Font 에서 설정

        다. 컴파일러 버전 변경
            elcipse의 window항목 > preference > Java > Compiler 에서 현재 21 --> 17로 변경.

        라. JRE 변경

	    elcipse의 window항목 > preference > installed JRE > 기존 JRE 삭제.

3. 자바 특징
  - OOP( Object Oriented Programming )
  - 플랫폼 독립적 ( OS 독립적 )
    가능한 이유가 JVM 덕분이다.
  - 개발자가 더 이상 메모리를 관리하지 않는다. ( GC: Garbage Collector )
    GC가 메모리에 있는 사용되지 않는 인스턴스(클래스가 메모리에 올라간 상태)를 자동으로 제거한다.

4. 자바 개발 환경 3가지 ( 기준: 디바이스(장치))

   1) Java SE ( Java Standard Edition )
      - 일반 PC 	
      - 자바 기술
      - 구축방법: JDK 설치

   2) Java EE ( Java Enterprise Edition )
      - 서버(웹 서버)
      - 웹페이지 개발 기술 ( Servlet & JSP )
      - 구축방법: Tomcat 설치

   3) Java ME ( Java Micro Edition )
      - 휴대용 장치 ( PDA, 셋탑박스 )


5. 이클립스 프로젝트 생성

  - module 는 체크 안함 (****************)
  
6. 자바 클래스 작성 ( *.java )

   - 반드시 첫글자는 영문자이고 또는 _ (언더바) 또는 $ 만 가능하다.
     이후에 숫자지정은 가능.
   
   - 대소문자 구별됨.
   - 특수문자는 _ (언더바) 또는 $ 2개만 가능.
   - 한글은 가능하지만 권장안함.
   - 자바클래스 첫글자는 반드시 대문자로 지정한다. ( 권장 )
  
   - 문법:
   
        public class 클래스명{
          
	    //구성요소 3가지
	    // 1. 변수
	    // 2. 생성자
	    // 3. 메서드

	}

   - 반드시 지정된 클래스명으로 파일을 저장해야 된다. ( 클래스명.java )
   - 자바에서는 클래스가 프로그램의 최소 단위이다.
     매우 비효율적이다. 따라서 함수형 프로그래밍이다.( 클래스 없이 메서드 사용 가능) 
     람다(lambda) 표현식이라고 부름. (****************)

7.  main 메서드

   - 하나의 자바 어플리케이션을 작성할때 반드시 존재하는 메서드임. (*************)
   - main 메서드 역할은 실행하기 위함이다. 즉 프로그램의 시작점 역할 담당 ( starting point )
     반드시 다음 문법을 따라야 된다.
     public static void main(String [] args){}


   * 최종 샘플 코드

   public class HelloTest {
	public static void main(String[] args) {

		System.out.println("Hello World");
	}
 
    }

   클래스는 몇개 일까요 ?  3개
   HelloTest.class ( 개발자가 직접 만든 클래스 )
   String.class    ( API ) 
   System.class    ( API )


8. 이클립스 단축키 (********)

   - 저장: ctrl + s
   - 단일문장 주석: ctrl + /
   - 한줄 복사: ctrl + alt + 화살표키
   - 줄바꿈: alt + 화살표키
   - 한줄 삭제: ctrl + d
   - 이전 작업 취소: ctrl + z
   - sysout + ctrl + spacebar 하면 자동으로 System.out.println() 생성.
   - 코드 자동 완성: ctrl + spacebar


9. 식별자 ( identifier )

  1) 개념
     자바소스에서 지정한 단어.

  2)식별자 지정 문법
   - 반드시 첫글자는 영문자이고 또는 _ (언더바) 또는 $ 만 가능하다.
     이후에 숫자지정은 가능.
   - 대소문자 구별됨.
   - 특수문자는 _ (언더바) 또는 $ 2개만 가능.
   - 한글은 가능하지만 권장안함.
   - 자바클래스 첫글자는 반드시 대문자로 지정한다. ( 권장 )

     public class 클래스명{
          
	    //구성요소 3가지
	    // 1. 변수
	    // 2. 생성자
	    // 3. 메서드

	}

    클래스명 권장방법: 첫글자 대문자, 의미있는 명사형
    변수 권장방법: 모두 소문자, 의미있는 명사형
    생성자: 반드시 클래스명으로 지정해야 된다.
    메서드 권장방법: 모두 소문자, 의미있는 동사형

  3) 식별자 종류 

    가. 시스템이 미리 예약한 식별자 ( 시스템 정의 식별자 )
       - 예약어(키워드) 라고 부른다.
        예> public,protected,private,class,interface,
	   abstract,final,default, switch, for, if,
	   transient,void, enum,.....

    나. 사용자 정의 식별자
       - 클래스,변수,메서드 식별자가 됨.
       - 시스템 정의 식별자(예약어) 이름으로 지정하면 안됨.

   
   * 리터럴 ( literal )
     - 자바코드상에서 사용된 데이터 (값 ) 의미.
     예> 문자열 데이터 :   "홍길동",  "hello"
                   반드시 쌍따옴표 지정.

        문자 데이터 :  '남', '여'
                   반드시 홑따옴표 지정.
	정수 데이터 : 100
	실수 데이터 : 3.14
	논리 데이터 : 참/거짓
	          true/false

    ==> 자바는 문자열과 문자를 다르게 처리한다. (*********)

 * 괄호
  (): 소괄호
  {}: 중괄호
  []: 대괄호


10. 데이터 종류 ( 데이터 타입, 데이터형 )- (********************************)
  - 개념: 자바언어가 처리할 수 있는 데이터 종류 의미함.

  1) 기본형 데이터 ( Primitive Data Type: PDT )
     - 수치형 데이터
              - 정수:  byte ( 크기: 1byte, 8bit )
	             short ( 크기: 2byte, 16bit )
		     int   ( 크기: 4byte, 32bit )- 기본
		     long  ( 크기: 8byte, 64bit )
                    
		   정수 표현:  10진수,2진수,8진수,16진수 모두 표현 가능.
		    예> 10진수: 0~9 이용해서 표현
		              100, -30, 0
                       2진수: 0|1 이용해서 표현, 접두사로 0b 지정
		             0b1, 0b0
		       8진수: 0~7 이용해서 표현, 접두사로 0 지정
		             01,02,.....07
                       16진수: 0~9, A,B,C,D,E,F 이용해서 표현, 접두사로 0x 지정
		             0x1,0x2,.....0xE, 0xF

	      - 실수:  float ( 크기: 4byte, 32bit )
	             double ( 크기: 8byte, 64bit )- 기본

                  float 표현:  3.14F, 3.14f
		  double 표혐: 3.14 , 3.14D, 3.14d

      - 문자:   char 이용 ( 2byte ). 기본형 타입이다.
           반드시 ''(홑따옴표) 이용해서 표현
	   예> '남',  'A'
           이스케이프 문자도 지원한다.
	   예> \t : 키보드 tab 효과
	      \n : 키보드 enter 효과
	      \" : " 를 출력
              \' : ' 를 출력 
	      \\ : \ 를 출력
           
	  유니코드(unicode)로 처리되기 때문에 전 세계의 모든 언어 표현이 가능하다.
	  유니코드는 \u값 으로 표현된다.

     - 논리 데이터 : boolean (불린) ( 크기: 1byte, 8bit )
               
                 boolean 표현:  true (참)
		              false (거짓)
    
  ==> 기본형은 총 8개.

  2) 참조형 데이터 ( Reference Data Type: RDT )
     - 기본형 8가지가 아닌 나머지 모두.
      대표적으로 클래스,배열,인터페이스 가 있음.
      반드시 클래스,배열,인터페이스를 데이터로 간주하자.(*************)
//////////////////////////////////////////////////////////////////
1일차 리뷰

1. 자바 3가지 환경

   Java SE: 기본개발환경, JDK 설치, 2가지 환경변수 설정 ( JAVA_HOME, PATH )
   Java EE: 웹 개발 환경 ( Servlet/JSP ), Tomcat 설치
   Java ME: 휴대용 모바일 환경

2. 자바특징
   - OOP(Object Oriented Programming) :객체 지향 프로그래밍 방법론
     나중에 함수형 프로그래밍(자바에서는 람다(lambda)라고 부름)과 AOP(Aspect Oriented Programming: 관점 지향 프로그래밍)
     방법론을 배운다.
   - 플랫폼에 독립적 ( 어떤 OS건 한번 만든 자바 어플리케이션을 바로 실행이 가능하다. )
     플랫폼에 의존적인 언어도 있음( C언어 )
   - 자동으로 사용하지 않는 메모리에 올라간 인스턴스를 제거해줌. Garbage Collector(GC)가 해줌.
     결국 자바 개발자는 메모리 관련되서 신경쓸 필요가 없다.

3. 자바 개발 순서

   1)소스작성 ( Hello.java )
     
   2)컴파일
     - 컴파일러 이용해서 컴파일 한다. ( javac.exe )
     - 문법:  javac Hello.java

        Hello.java ---------------> Hello.class ( bytecode 라고 부름 ) 

   3)실행
     - 인터프리터 이용해서 실행 ( java.exe )
     - 문법:  java Hello
  
         Hello.class ------------------> 결과 출력

4. JVM ( Java Virtual Machine )

  - 역할: bytecode 를 실행하는 역할.
  - 구축방법: JDK 설치
  - H/W 느낌이 나지만 명백한 S/W 임.
   그런데 H/W 특징을 가짐 ( 다양한 메모리를 가짐 )
  - 주요 메모리 3가지: stack, heap, method area (******************)

5. 자바의 데이터종류 ( 데이터타입, 데이터형 )

  1) 기본형 데이터 ( Primitive Data Type :PDT )
  
      - 수치형 
             정수형 : byte  ( 1byte )
	            short ( 2byte )
		    int  ( 4byte ) - 기본 ( 만약 100 이라고 지정하면 int로 처리됨 )
		    long ( 8byte )
                   
		   - 10진수,2진수,8진수,16진수 표현 가능.

	     실수형 : float ( 4btye )
	            double ( 8byte ) - 기본 ( 만약 3.14 이라고 지정하면 double로 처리됨 )

		    float 표현: 3.14F, 3.14f
                    double 표현: 3.14, 3.14D, 3.14d

		    지수 표현 가능: 140.0 는 1.4E2로 표현 가능.

      - 문자형 : char ( 2byte )
               유니코드로 처리되기 때문에 전세계의 모든 언어 표현 가능.

      - 논리형 : boolean ( 1byte)
               true/false


  2) 참조형 데이터 ( Reference Data Type :RDT )

     - 기본형 8개를 제외한 나머지가 모두 참조형이다.
      대표적으로 클래스, 배열, 인터페이스가 있다.

///////////////////////////////////////////////////////////
2일차

1. int 와 long 

   - int 는 정수형의 기본타입이다.
     즉 만약 100 이라고 지정하면 int로 처리됨.

   - 만약 long 으로 처리하고자 한다면
      100L 형식으로 표현한다.
   
2. 문자와 문자열

  - 기본적으로 자바는 문자와 문자열을 다르게 처리한다.
  - 문자:   char 이용. 기본형 타입이다.
           반드시 ''(홑따옴표) 이용해서 표현
	   예> '남',  'A'
           이스케이프 문자도 지원한다.
	   예> \t : 키보드 tab 효과
	      \n : 키보드 enter 효과
	      \" : " 를 출력
              \' : ' 를 출력 
	      \\ : \ 를 출력
           
	  유니코드(unicode)로 처리되기 때문에 전 세계의 모든 언어 표현이 가능하다.
	  유니코드는 \u값 으로 표현된다.


    문자열:  String 클래스 이용, 참조형 타입이다.
           반드시 ""(쌍따옴표) 이용해서 표현
	   예> "남자",  "ABC"


3. wrapper 클래스 

 - 개념: 기본형 8개에 해당되는 8개의 클래스(API)를 묶어서 표현하는 이름.

  기본형              wrapper 클래스(참조형)
-----------------------------------
  byte		    Byte
  short             Short
  int               Integer
  long              Long

  float             Float
  double            Double

  char              Character

  boolean           Boolean


- API로 wrapper 클래스를 제공하는 이유: 기본형 데이터를 사용할 때 여러가지 정보 및 가공(동작)처리를 원활하게 할수 있도록 지원.
 
  예>  3.14 -----> 3 
       3---------> 3.0
      int(4byte)에 저장 가능한 정수크기?


4. 변수 ( Variable )

  1) 용도
    - 데이터(리터럴)를 저장.
    - 기본형 8 개 및 참조형(클래스,배열,인터페이스)도 변수에 저장할 수 있음.

  2) 기본 문법-1

     가. 변수 선언
        - 데이터가 저장될 영역 확보 작업
	- 문법:
	   
	     데이터형  변수명;

           예> 
	       // 기본형 타입
	       byte n;  // 1byte크기의 영역확보, 그 영역은 n 으로 접근.
	       short n2; // 2byte크기의 영역확보, 그 영역은 n2 으로 접근.
	       int n3;
	       long n4;
	       float f;   // 4byte크기의 영역확보, 그 영역은 f으로 접근.
	       double f2;  // 8byte크기의 영역확보, 그 영역은 f2으로 접근.
	       char c;     // 2byte크기의 영역확보, 그 영역은 c으로 접근.
	       boolean b;  // 1byte크기의 영역확보, 그 영역은 b으로 접근.

               // 참조형 타입
	       String s;  // 무조건 4byte크기의 영역확보, 그 영역은 s으로 접근.
               Byte s2;   // 무조건 4byte크기의 영역확보, 그 영역은 s2으로 접근.


     나. 초기화

       - 변수에 맨 처음 값을 저장하는 것을 의미.
         반드시 저장되는 값은 변수의 데이터형과 일치해야 된다.
       - 문법:
          
	     변수명 = 값;

          예>  int n3;
	      char c;
	      String s;

	      n3= 10;
	      c = '남';
	      s = "홍길동";

      
     다. 값변경 및 사용(출력)

            n3 = 20;
	    c = '여';

	   System.out.println(n3);
	   System.out.println(c);
	   System.out.println(s);

   2) 기본 문법-2

      - 변수선언과 초기화를 한꺼번에 지정 가능

      - 문법:

          데이터타입 변수명 = 값;

       예> 
           int n = 10;
	   char c = '남';
	   String s = "홍길동";

   2) 기본 문법-3

     - 같은 타입의 변수가 여러개 일 때 사용 가능. 권장안함

      예>
          int n;
	  int n2=10;
	  int n3;

      ==> int n,n2=10,n3;  ( 권장안함)


5. 변수의 종류-1 (*************)
  
   1) 데이터 종류에 따라서 분류

    가. 기본형 변수
       - 기본형 데이터가 저장된 변수

       예> int n = 10;  // n은 변수
                          n은 int 타입의 변수
			  n은 정수형 변수
			  n은 기본형 변수
          char c = '남'; // c은 변수
	                   c는 char 타입의 변수
                           c는 문자형 변수
                           c는 기본형 변수

       - 기본형 변수는 변수에 실제 데이터가 저장되어 있음 (*******)
 
    나. 참조형 변수
       - 참조형 데이터가 저장된 변수

       예> String s = "홍길동";  // s는 변수
                                 s는 String 타입의 변수  
                                 s는 문자열 타입의 변수
				 s는 참조형 변수

       - 참조형 변수는 변수에 실제 데이터가 저장되어 있는 주소값이 저장되어 있음 (*******)
         즉 클래스,배열,인터페이스 타입의 변수는 참조형 변수이기 때문에 주소값이 저장되어 있다. (*******)

5. 변수의 종류-2 (*************)

   - 변수 선언 위치와 용도에 따른 분류

   1)로컬 변수     ( local variable, 지역변수)
    - 변수선언위치:  메서드 안에서 선언된 변수
    - 생성시점:  메서드 실행 ( 메서드는 호출해야 실행이 된다. )
      소멸시점:  메서드가 끝날때
    - 저장메모리: stack 메모리
    - 생성횟수: 메서드가 호출해서 실행될때 마다 매번 생성
             메서드가 끝나면 매번 제거됨.
    - 용도: 일시적으로 임의의 데이터 저장하기 위해서 주로 사용됨.
    - 주의할 점: 반드시 사용하기 전에 초기화해야 된다.

   2)인스턴스 변수  ( instance variable )
    - 변수선언위치:  메서드 밖에서 선언된 변수
    - 생성시점: 클래스를 객체 생성할 때 ( 클래스 객체 생성는 new 키워드 이용)
      소멸시점: 메모리에 올라간 객체(인스턴스)가 소멸될 때
    - 저장메모리: heap 메모리
    - 생성횟수: 객체생성할때 마다 매번 생성됨.
    - 용도: 객체의 속성을 저장할 때 사용.
    - 초기화하지 않으면 자동으로 초기화 된다.
       기본형 데이터:  정수: 0
                   실수: 0.0
		   문자: \u0000  ( 빈문자)
		   논리: false
		   
       참조형(클래스,배열,인터페이스) 데이터: null

   3)클래스 변수    ( class variable, static variable )
    - 변수선언위치:  메서드 밖에서 선언된 변수 + static 키워드 지정
    - 생성시점: 프로그램 실행시 생성
      소멸시점: 프로그램 종료시 제거
    - 저장메모리: method area 메모리
    - 생성횟수: 1 번만 생성됨.
    - 초기화하지 않으면 자동으로 초기화 된다.
    - 초기화하지 않으면 자동으로 초기화 된다.
       기본형 데이터:  정수: 0
                   실수: 0.0
		   문자: \u0000  ( 빈문자)
		   논리: false
		   
       참조형(클래스,배열,인터페이스) 데이터: null

6. 변수의 특징

  - 같은 이름으로 선언 안됨.
    이유는 식별이 불가능하기 때문이다.

  - 로컬변수는 반드시 사용전에 초기화 해야 된다. ( 컴파일 에러 발생 )

  - 선언된 변수를 인식하는 범위(scope)는 블럭단위( {} ) 이다. (****************)
   자바는 블럭 scope를 따른다.
   자바스크립트는 함수 scope를 따른다.
   

7. 상수
 
  - 값 변경이 불가
  - 문법:
   
     final 데이터타입 상수명=값;   // 초기화 된 값은 변경이 불가

  - 변수와 구별하기 위해서 상수명은 대문자로 지정한다.
    단어와 단어사이는 _(언더바) 사용.

   예> Byte.MIN_VALUE

  - 일반적인 상수는 public static final 키워드를 지정해서 사용한다. ( 관례 )


8. 데이터 타입 변환 (데이터형 변환 )

  1) 개념
    서로 다른 데이터타입(데이터형)이 프로그램 실행중에 원래의 데이터형을 버리고
    새로운 데이터 형으로 변경되는 것을 의미한다.
    예> int--->byte
       byte-->int
       int --> float
       
  2) 형변환 방법

     가. 명시적 형변환 ( 강제 형변환, type casting, down-casting )
        - 일반적으로 의미하는 형변환을 말함.
        - 형변환 연산자 이용

	 문법: 
	      작은타입 = 큰타입;  //에러
              작은타입 = (작은타입)큰타입;  // 형변환
          예>
	      int n = 10;
	      short s =  n; //에러
	      short s =  (short)n; // 형변환

	 - 데이터 손실이 발생될 수 있음.

     나. 묵시적 형변환 ( 자동 형변환, promotion, up-casting )

       a.  byte > short > int > long > float > double , 역은 에러 발생됨.
       b.  char > int  ( 아스키코드 )
          예> 'A'--> 65
	     'a'--> 97

	  내부적으로 char가 연산이 가능하다.

      c. int 보다 작은 데이터형의 연산결과는 int로 반환된다.
      d. 작은 데이터와 큰 데이터의 연산결과는 큰데이터형으로 반환된다.
        예> 정수 + 실수 ==> 실수
 
      e. 출력할 때 문자열과 비문자열을 + 하면 문자열로 반환된다. ( 연결되어 문자열로 반환됨 )
       
        예>  "hello"+1  =====> hello1

   3) 데이터형변환은 기본형 데이터뿐만 아니라
      참조형 데이터인 클래스도 형변환(명시적/묵시적) 될 수 있다. (***************************)

      예> String s = "hello";
         Object s2 = s;   // String 인 s가 Object 형으로 자동 형변환 됨.

9. 표준 출력 ( standard output )

        입력(input)                 출력(output)  => I/O
   외부 ----------> 자바프로그램(기준)------------> 외부
  (소스)                                      (목적지) 
 - 키보드(표준입력)                              - 모니터(표준출력)
   파일                                         파일
   네트워크                                      네트워크

  1) 개념
    표준 출력인 모니터에 데이터를 출력하는 방법.

  2) 방법 3가지

   가. System.out.println(값);
      - 반드시 값은 하나만 지정가능.
        만약에 여러값을 지정하려면 하나의 값으로 만들어야 된다. + 이용.
      - 여러번 사용시 새로운 줄에 출력이 된다.

   나. System.out.print(값);
     - 반드시 값은 하나만 지정가능.
       만약에 여러값을 지정하려면 하나의 값으로 만들어야 된다. + 이용.
     - 여러번 사용시 동일한 줄에 출력이 된다.
       즉 줄 변경이 안됨.


   다. System.out.printf("형식문자", 값, 값2, ... );   // 가변인자 라고 부르고 갯수는 정해져 있지 않음.
      문법: printf(String format, Object... args)

     - 형식문자(%표현식)의 갯수와 값의 갯수가 일치해야 된다.
      https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Formatter.html#syntax

      문자열: %s
      정수: %d
      실수: %f
      문자: %c
      논리: %b

      예> System.out.printf("%s", "홍길동");
         System.out.printf("%d", 100);
	 System.out.printf("%b", true);
	 System.out.printf("%f", 3.14);

	 System.out.printf("%s, %d, %b", "홍길동", 20, true);

 실제로는  System.out.printf("이름: %s, 나이:%d, 결혼여부:%b", "홍길동", 20, true);
       
    - 여러번 사용시 print 와 동일하게 한 줄로 출력이 된다.

////////////////////////////////////////////////////////////////////////////
1,2 일차

1. 자바의 데이터 종류

   1)기본형(primitive data type: PDT)
     
      -수치형: 
          정수형: byte ( 1byte )
	        short( 2byte ) 
		int  ( 4byte ) - 기본
		long ( 8byte )
             
              표현식: 10진수, 2진수(0b), 8진수(0), 16진수(0x)
	      long 타입으로 표현할 때는 100L 사용한다. 

	  실수형: float ( 4byte )
	        double ( 8byte ) - 기본
           
	   표현식: 소수점으로 표현, 지수표현 가능
	        float: 3.14F, 3.14f
                double: 3.14, 3.14D, 3.14d


      -문자형(수치형) : char (2byte)
                   유니코드이기 때문에 전세계의 모든 언어 표현이 가능.
		   escape 문자 지원 ( \t,\n,\",\',\\ )
               표현식: '홍', '남'
	       * 자바는 문자와 문자열을 구분해서 처리한다.
                 문자열을 String 클래스로 관리한다.
		 자바스크립트는 문자와 문자열을 구분 안함.

      -논리형: boolean ( 1byte )
           표현식: true/false
           
	   자바스크립트는  true/false 및 임의의 값도 논리형으로 사용이 가능하다.
	   예> 0,"",null,undefined,NaN    ==> false 로 처리
	      100  ==> true 로 처리
            

   2)참조형(reference data type: RDT)

     - 기본형 8개 제외한 나머지.
      대표적으로 클래스, 배열, 인터페이스 이다.


2. 변수 ( variable )

 1)용도: 데이터 저장
 2)문법:
        데이터형 변수;  // 변수에 지정된 데이터형만 저장이 가능하다.
	변수=값;

	데이터형 변수=값;

        자바스크립트는 변수선언시 데이터형을 지정하지 않는다.

 3)특징
   - 변수명은 유일.
   - 변수에 저장되는 값은 하나. ( 만약에 여러값이면 하나로 만들어야 됨)
   - 변수 scope는 블럭 scope이다. ( {} )
     자바스크립트는 함수 scope 이다.

 4)종류1
  - 어떤 데이터를 저장했는지 여부

   가. 기본형 변수
      - 기본형 8개를 저장한 변수.
      - 변수에 가면 실제값이 있음.

   나. 참조형 변수
      - 클래스, 배열, 인터페이스를 저장한 변수
      - 변수에 가면 실제값이 없고 실제값이 저장된 주소값을 가짐.

 4)종류2
  - 변수 선언 위치에 여부

    가.로컬변수
      -선언위치: 메서드안에서
      -생성시점: 메서드 호출
       삭제시점: 메서드가 종료
      -메모리: stack
      -특징: 반드시 사용전에 초기화 ( 컴파일 에러 )
 
    나.인스턴스변수
      -선언위치: 메서드밖에서
      -생성시점: 객체생성( new )
       삭제시점: 객체소멸
      -메모리: heap
      -특징: 변수가 자동 초기화 됨.
            정수: 0
	    실수: 0.0
	    문자: \u0000 (빈문자)
	    논리: false

	    참조형:null

    다.클래스변수(static변수)
      -선언위치: 메서드밖에서 + static 지정
      -생성시점: 프로그램 실행
       삭제시점: 프로그램 종료
      -메모리: method area	 
   -특징: 변수가 자동 초기화 됨.
    정수: 0
    실수: 0.0
    문자: \u0000 (빈문자)
    논리: false

    참조형:null

3. 데이터형 변환

   가. 묵시적형변환
      - byte > short > int > long > float > double
      - char > int
      - 작은 데이터와 큰 데이터 연산 ==> 큰 데이터 형
      - int 보다 작은 데이터의 연산 ==> int
      - 문자열 + 비문자열 ==> 연결되어 문자열로

   나. 명시적형변환
      - (타입)

  ==> 기본형 및 참조형에서도 데이터형 변환이 가능하다. (***********)

4. 표준 출력
 - 모니터에 값 출력 의미

  가. System.out.println(값)
  나. System.out.print(값)
  다. System.out.printf("형식문자", 값, 값2,.... ) <== 가변인자임. ( ... )

///////////////////////////////////////////////////////////////////////
3일차

1. 연산자 ( operator )

  가. 산술연산자

   값1 + 값2
   값1 - 값2
   값1 * 값2
   값1 / 값2
   값1 % 값2 (나머지)

 # + 값이 산술연산자가 아닌 연결연산자로 사용되는 경우도 있다.
  => 문자열 + 비문자열 결과는 연결되어 문자열로 반환된다.
  예> "hello"+1+2 ==> "hello12"

  나. 대입연산자
     용도: 변수에 값을 할당(대입)하는 역할

     변수 = 값;
     a = b;   // a 에 b값을 할당(대입)

    변수 += 값;
     a += b;  // a = a + b; 동일 

     a -= b;  // a = a - b; 동일 
     a *= b;  // a = a * b; 동일 
     a /= b;  // a = a / b; 동일 
     a %= b;  // a = a % b; 동일 

  다. 비교연산자
   용도: 값(기본형)을 비교하는 기능
       (참조형은 클래스,배열,인터페이스이기 때문에 비교연산자를 사용하는 경우는 거의 없다. )
   특징: 실행결과는 항상 논리형으로 반환됨. ( true/false)

   a == b;  // a 와 b 가 같냐?
   a != b;  // a 와 b 가 같지 않냐?
   a > b;  // a 가 b 보다 크냐?
   a >= b;  // a 가 b 보다 크거나 같냐?
   a < b;   // a 가 b 보다 작냐?
   a <= b;  // a 가 b 보다 작거나 같냐?

   -자바스크립트에서는  === , !==  연산자가 더 있음.
   -만약에 참조형변수를 == 하면 주소값 비교가 된다.

     예> 참조형변수1 == 참조형변수2 는 주소값 비교가 됨.

   - 문자열 비교시에는 절대로 == 사용하면 안됨. (******************)
    예> String s = "홍길동";
       String s2 = "홍길동"; 
 
       //  문제: s와 s2가 같냐?
       System.out.println( s == s2 ); // 절대로 사용하지 말것. 실제 홍길동 값이 아닌 주소값을 비교하는 코드이다.

       System.out.println( s.equals(s2) ); // 실제 홍길동값을 비교하는 코드이다.


  라. 논리 연산자
  
    용도: 논리값(true/false)을 이용해서 연산하는 기능.
    특징: 실행결과는 항상 논리형으로 반환됨. ( true/false)

     &&: and (그리고) 해석,  and 연산자

       논리값1 && 논리값2 <== 논리값1 과 논리값2 가 모두 true인 경우에만 최종적으로 true 가 반환됨.
                          하나라도 false 인 경우에는 최종적으로 false 가 반환됨.
     
     ||: or ( 또는 ) 해석,  or 연산자

       논리값1 || 논리값2  <== 논리값1 과 논리값2 중에서 하나라도 true인 경우에는 최종적으로 true 가 반환됨.
                           모두 false 인 경우에는 최종적으로 false 가 반환됨.

     ! : not (부정) 해석,   not(부정) 연산자

       !논리값

 
    - 실제로는 논리값(true/false)를 사용하지 않고 실행결과가 논리값으로 반환되는 연산자(비교연산자)를
      사용하는 것이 일반적이다.

      예>  true && false

          int n = 10;
	  (n > 20) && (n < 10)

    - 여러개의 논리값 사용 가능
     예> 논리값1 && 논리값2 || 논리값3 ...

    - short circuit logical 연산자로 동작됨.
     연산자의 앞의 논리값만 확인해서 실행결과가 정해지면
     두번째 논리값은 실행되지 않고 최종적인 결과가 반환되는 매커니즘 의미.

  마. 증감 연산자 ( 증가 연산자 와 감소 연산자 )

    용도: 값을 1씩 증가 또는 1씩 감소하는 기능.

    문법:
         a. 증가 연산자
	    
	    ++변수명;    // 전치 연산자, 변수명=변수명+1; 동일,  변수명 += 1;
	    변수명++;    // 후치 연산자, 변수명=변수명+1; 동일,  변수명 += 1;

	 b. 감소 연산자

            --변수명;    // 전치 연산자, 변수명=변수명-1; 동일,  변수명 -= 1;
	    변수명--;    // 후치 연산자, 변수명=변수명-1; 동일,  변수명 -= 1;

    주의할점: 증감 연산자를 다른 연산자와 같이 사용하는 경우 실행 결과값이 달라질 수 있다.

          예>  int n = 10;


              int n2 = ++n;  // 전치는 ++ 하고 나중에 = 실행
	      int n2 = n++;  // 후치는 = 하고 나중에 ++ 실행

   바. 3항 연산자

    문법: 변수 = (조건식)?참값:거짓값;

    특징: 중첩이 가능.

        변수 = (조건식)? 3항연산자:거짓값;
	변수 = (조건식)? 참값:3항연산자;


2. 표준 입력 ( standard input )
 
  1) 개념
    키보드로 데이터를 입력 받음을 의미.
    
    키보드 의미: System.in
    모니터 의미: System.out

  2) 방법 2가지

    가. java.io 패키지의 API 이용

             입력                      출력
              
              ?                        ?
	    (byte,char)              (byte,char)
	소스 ------> 자바어플리케이션(기준) ------> 대상
      키보드                                 모니터
      파일                                   파일
      네트워크                                네트워크

     
      byte 입력: ~~~~InputStream
      byte 출력: ~~~~OutputStream

      char 입력: ~Reader
      char 출력: ~Writer

    
    나. java.util 패키지의 API 이용

      - Scanner 클래스 이용.

      a. 경로를 지정해야 한다.

        import java.util.Scanner;


      b. Scanner 클래스를 객체 생성해야 된다.
         ( 클래스를 사용할때는 반드시 객체 생성해야 된다.
	   객체생성하면 메모리에 올라갈 수 있다.
	 )
  
        문법:  클래스명  변수 = new 클래스명([값1,값2,...]);

          Scanner scan = new Scanner(System.in);

	  ....
	  scan.close(); // 마무리

      c. 데이터를 읽는 다양한 방법의 메서드 제공

        정수값으로 읽기:
                     int n = scan.nextInt();

	문자열(단어)로 읽기:

	            String s = scan.next();

		    예>
		       홍길동 이순신 

        한 줄 읽기:   String s = scan.nextLine();


 

3. 문장 (statement)

 1) 문장종류

      가. 실행문
              - 순차문: main 메서드의 첫라인부터 순차적으로 실행되는 문장.
	              거의 90% 이상 차지함.

	      - 제어문: 
	        
		   조건문(분기문):  조건식에 따라서 실행되는 문장이 달라진다.
                              종류: 단일 if문
			           if~else문
				   다중 if문  ( 동등 및 부등 이용한 경우 )
				   switch 문 ( 동등 연산 이용한 경우 )

		   반복문: 조건식에 따라서 한번 실행된 문장이 여러 번 실행될 수 있다.
                              종류: for문
			           while문
				   do~while문

      나. 비실행문
         - 자바가 실행하지 못하는 문장의미.
	 - 일반적으로 주석문이라고 부른다.

	    한줄 주석문:  // 문장
	    멀티 주석문:  /*
                         문장
	               */


  2) 조건문

    가. 단일 if문
     용도: 조건식(true/false) 결과에 따라서 문장의 실행여부가 결정되는 문장.
          즉 true 인 경우에만 실행되고 false 인 경우에는 실행이 안되는 경우.

     문법:

        a. {} (블럭) 없는 경우

	    if(조건식) 문장1; // 조건식에 따른 영향을 받음.
	                      조건식이 true 인 경우에만 문장1 이 실행됨.
	             문장2; // 조건식에 따른 영향을 안받음. 

	b. {} (블럭) 있는 경우 ( 권장 ) ==> {} 역할은 영향 미치는 문장을 묶어주는 역할.


	    if(조건식){      // 조건식에 영향을 받는 문장은 {} 전체임.
		    문장1;
	    }
	            문장2;

	     if(조건식){      // 조건식에 영향을 받는 문장은 {} 전체임.
		    문장1;
		    문장2;
	    }
	            

   나. if~else문
     용도: 조건식(true/false) 결과에 따라서 실행되는 문장이 달라지는 경우.
         true인 경우에는 if문(if블럭) 실행하고 false인 경우에는 else문(else블럭) 실행.
     문법:

        a. {} (블럭) 없는 경우

	   if(조건식)
	       문장1;
	   else  
	       문장2;

       b. {} (블럭) 있는 경우 ( 권장 )

           
	   if(조건식){ 
	      문장1; // 조건식이 true 인 경우에 실행
	   }else{
	      문장2; // 조건식이 false인 경우에 실행
	   }

  다. 다중 if문
    용도: 여러번 조건식을 이용해서 비교할 때.
  
    문법:
     
         if(조건식1){
             문장1;
	 }else if(조건식2){
             문장2;
	 }else if(조건식3){
             문장3;
	 } // 단일 if문으로 끝나는 경우

	  if(조건식1){
             문장1;
	 }else if(조건식2){
             문장2;
	 }else if(조건식3){
             문장3;
	 }else{
             문장4;
	 } // if~else문으로 끝나는 경우

  
   라. switch 문

     용도: 다중 if문 처럼 조건이 여러 개인 경우 사용됨.
     특징: 조건식에 사용되는 연산자가 없음.
          내부적으로 == 사용됨

     문법:

          switch( 변수 ){
            case 값1(리터럴): 문장1; break;
            case 값2(리터럴): 문장2; break;
	    case 값3(리터럴): 문장3; break;
            default: 문장n;		
	  }

      case에 지정하는 값의 데이터 타입은 6개만 가능하고 유일해야 된다.
       ( byte, short, int, char, String, enum )

      일치하는 case 문을 만나면 이후의 문장들은 모두 실행된다.
      만약 일치하는 문장만 실행하고 switch문을 빠져나오려면 break 키워드를 사용해야 된다. 
      즉 break 키워드는 옵션 선택이다.


  마. 조건문 사용시 특징
   
     - {} 사용하기 때문에 변수 scope 를 고려해야 된다.

      예>
          if(조건식){
	     int num= 10;

	  }
         System.out.println(num); //  에러 발생

     - 중첩 가능
     
       예>
           if(조건식){
	     ..
               if(조건식){

	       }

	  }
         
///////////////////////////////////////////////////////////////////////
4일차

1. 반복문

  예>  hello 문자열을 5번 출력하시오.

   횟수 
    1    "hello" 출력
    2    "hello" 출력
    3    "hello" 출력
    4    "hello" 출력
    5    "hello" 출력
    6    중단

    10
    9
    8
    7
    6
    5 중단

 반복문에 필요한 요소

   가. 시작값(초기값) 필요 ==> 1 또는 10 를 저장. 변수 사용
       int n = 1;
       int n2 = 10;

   나. 시작값을 증가/감소 ==> 연산자 이용
       1씩증가: n++, ++n
       1씩감소: n2--, --n2
       2씩증감: n+=2 ( n=n+2)
              n-=2 ( n=n-2)

   다. 반복을 중단하기 위한 조건식 필요
       n < 6

  
  위 3가지중에 하나라도 설정하지 않거나 잘못 설정하면
  반복이 아예 안되거나 무한루프에 빠질 수 있다.


  1) for 문
   
   문법: for(시작값(초기값) ; 조건식 ; 증감식){
	   문장1;
	   문장2;
	   ..
        }
   특징: 3가지 구성요소가 서로 뭉쳐있기 때문에 반복횟수를 예측이 가능하다.
       따라서 반복횟수가 예측이 가능한 경우에 사용된다.

  예>
      for( int n = 1  ;  n < 6  ; ++n ){
        System.out.println("hello");
      }

    
 2) while 문
  - 기본문법은 조건식만 지정한다.
   하지만 정확한 반복을 할려면 초기값과 증감식이 반드시 필요하다.
   초기값과 증감식은 적절한 위치에 설정해야 된다.
  문법:
       
       초기값;
       ...

       while(조건식){
           문장1;
	   문장2;
	   ..
	증감식;
       }
   
  특징: 3가지 구성요소가 서로 떨어져 있기 때문에 반복횟수를 예측하기가 어렵다.
       따라서 반복횟수 예측이 어려운 경우에 사용된다.
       무한루프 사용시 while문을 주로 사용된다.
       조건식이 맨 처음부터 false이면 문장을 한 번도 실행되지 못할 수도 있음.
       
       //무한루프
       while(true){
          문장1;
       }
  
  3) do~while 문
  - 기본문법은 조건식만 지정한다.
   하지만 정확한 반복을 할려면 초기값과 증감식이 반드시 필요하다.
   초기값과 증감식은 적절한 위치에 설정해야 된다.
  
  -특징:  조건식이 나중에 실행되기 때문에 적어도 한번은 무조건 문장이 실행될 수 있음.

  문법:
     
      초기값:
      ..
      do{
        문장;
        증감식;
      }while(조건식);

 
  4) 반복문의 고려사항

    - {} 가지고 있기 때문에 변수 scope 를 고려하자. 
    - 모든 제어문(조건문, 반복문)은 서로간에 중첩이 가능하다.
     예>
         if(){
	   for(){}
         }

	 for(){
	   if(){}
	 }

	 for(){
	   for()
	 }

    5)  반복문에서 사용 가능한 2가지 키워드

     가. break
       용도: (조건식이 만족하더라도)반복문을 빠져 나올때 사용.
       문법:
            for(;조건식1;){
             if(조건식2)break;  // {} 지정 안함.
             ...
           }

     나. continue

       용도: 반복해야되는 여러 문장들 중에서 특정 문장들의 실행을 skip할 때 사용.
            즉 특정 반복회차에서 skip 함.
       
       문법:

            for(;조건식1;){
               문장1;
	       if(조건식)continue;
	       문장2;
	       문장3;
           }





/////////////////////////////////////////////////////////////////////
 * 자바에서 데이터를 저장하는 방법 3가지 ( ************) 
  
   1) 변수(variable)
     - 값(데이터) 하나만 저장이 가능.
     - 변수에 저장 가능한 값의 종류 기본형 데이터(기본형 변수)도 가능하고
              참조형 데이터(참조형 변수)도 가능하다.

   2) 배열(array)
     - 여러개의 값을 저장이 가능.
     - 배열에 저장되는 데이터는 모두 동일한 데이터형이어야 됨.
     - 배열에 저장 가능한 값의 종류는 기본형 및 참조형 모두 가능하다. ( 단, 기본형 데이터는 wrapper 클래스(참조형)를 이용해서 저장한다. )
       즉 배열은 참조형만 저장이 가능하다.
       배열 자체는 참조형이다. 즉 배열에는 주소값이 저장되어 있고 주소값을 참조하면 저장된 실제 데이터가 있음.

     - 단점: 한번 생성된 배열은 크기 변경이 불가.  
            모두 동일한 데이터형만 가능. 

   3) 컬렉션(collection)
     - 여러개의 값을 저장이 가능.
     - 컬렉션에 저장되는 데이터는 모두 달라도 무관.
     - 컬렉션에 저장 가능한 값의 종류는 기본형 및 참조형 모두 가능하다. ( 단, 기본형 데이터는 wrapper 클래스(참조형)를 이용해서 저장한다. )
       즉 컬렉션은 참조형만 저장이 가능하다.
       컬렉션 자체는 참조형이다. 즉 배열에는 주소값이 저장되어 있고 주소값을 참조하면 저장된 실제 데이터가 있음.

     - 장점: 한번 생성된 컬렉션은 크기 변경이 가능. 
            데이터는 모두 달라도 무관.

     - 대표적인 3가지 컬렉션 종류 ( java.util 패키지 )
       
       가. List 계열 ( XXXList.class )
          - 저장되는 순서가 존재함.
	  - 중복데이터 저장이 가능.
	  - 대표적인 클래스는 ArrayList.class

       나. Set 계열  ( XXXSet.class )
          - 저장되는 순서가 없음.
	  - 중복데이터 저장이 불가능. ( 중복 데이터는 한번만 저장됨 )
          - 대표적인 클래스는 HashSet.class
	  
       다. Map 계열  ( XXXMap.class )
           - 저장되는 순서가 없음.
	   - 저장되는 데이터의 이름(name,key)를 같이 저장한다.
	     key/value 쌍으로 저장.
           - 대표적인 클래스는 HashMap.class
/////////////////////////////////////////////////////////////////////

2. 1차원 배열 ( array )

  1) 용도
    - 데이터 저장
   
  2) 문법-1 ( new 이용 )

      (변수,참조형변수, 배열명)
       num(0x100) --------------------> |10|20|30|40|50|
                                          0  1  2  3  4   (인덱스, 첨자)

       배열길이: num.length
       배열요소접근: num[0]
                 ..
		 num[4]
  
    가. 배열선언

        데이터형 [] 변수; // 권장    
	데이터형  변수 [] ;  

     예> int [] num;
       
        (변수,참조형변수, 배열명)
         num

   ///////////////////////////////////
    * 다음 2가지 형태를 구별해야 된다.
     
      가. int num1;  
       
         num1의 데이터 타입? ( int )
         num1에 저장되는 데이터는 ? 값이다. ( 정수형 )
	 num1의 데이터 타입은 기본형 및 참조형 중에서 ? 이다. ( 기본형 )

      나. int [] num2;

         num2의 데이터 타입?  (int [], 배열 )
         num2에 저장되는 데이터는 ? 값이다. ( 주소값 )
         num2의 데이터 타입은 기본형 및 참조형 중에서 ? 이다. ( 참조형 )

   /////////////////////////////////


   나. 배열생성 ( new 이용 )

      배열명 = new 데이터타입[크기];

     예> int [] num; // 로컬변수, stack 저장
         num = new int[5]; // heap 저장, 자동으로 초기화됨.

      (변수,참조형변수, 배열명)
       num(0x100) --------------------> |0 | 0| 0 | 0 | 0 |
                                          0  1  2   3   4   (인덱스, 첨자)

   다. 배열 요소 접근

      배열명[인덱스]; // 인덱스(index)는 0 부터 시작, 
                     인덱스(index)는 배열크기(길이) 보다 항상 1이 작음.

      num[0]=10;
      num[1]=20;
      num[2]=30;
      num[3]=40;
      num[4]=50;

     (변수,참조형변수, 배열명)
       num(0x100) --------------------> |10| 20| 30 | 40 | 50 |
                                          0  1   2    3    4   (인덱스, 첨자)


     * 요소 접근시 주의할 점
      없는 인덱스를 사용하면 에러가 발생된다.
      예>  num[5]=60; // 에러가 발생된다. java.lang.ArrayIndexOutOfBoundsException 발생됨.


    - 배열선언과 배열생성을 한번에 작성 가능

     예> int [] num = new int[5];

    - 배열요소 접근하는 3 가지 방법
      
      a. 배열명[인덱스] 사용해서 직접 요소 접근
	System.out.println(num[0]);
	System.out.println(num[1]);
	System.out.println(num[2]);
	System.out.println(num[3]);
	System.out.println(num[4]);

      b. for 문 이용

        for(int idx=0; idx < num.length   ; idx++ ){
          	System.out.println(num[idx]);
	}

      c. foreach 문 이용 ( 향상된 for문 )

        for( 변수: 배열명){
          System.out.println(변수);    
	}

	for( int n: num ){
          System.out.println(n);    
	}

 2) 문법-2 ( new 이용하지 않고 리터럴값만 이용 )
     
     배열선언과 배열생성과 초기화가 한꺼번에 이루어짐.
     따라서 한줄에 설정해야 된다.

     데이터형 [] 변수명 = { 값, 값2, ...   };

   예> //문법1
      
        int [] num;
	num = new int[2];
	num[0]=10;
        num[1]=20;

      //문법2
       int [] num = {10,20};
    
 2) 문법-3 ( 문법1(new) + 문법2(리터럴) 혼합 )

    데이터형 [] 변수;
    변수 = new 데이터형[]{값, 값2, ..}; // 명시적으로 크기지정 불가

    예> //문법1
      
        int [] num;
	num = new int[2];
	num[0]=10;
        num[1]=20;
 
        int [] num = new int[2];

       //문법2
       int [] num = {10,20};

       //문법 3
       int [] num;
       num = new int[]{10,20};

       int [] num = new int[]{10,20};

3. main 메서드의 파라미터인 String [] args 배열을 사용하는 용도

    예> Test.java
           |       <== 컴파일: javac Test.java
       Test.class
           |       <=== 실행:  java Test 값 값2 ...
         실행결과               java Test 10 홍길동  3.14

   값 값2 ... 자동으로 main메서드의 파라미터인 String [] args 에 배열로 저장이 된다.
   입력된 값은 모두 문자열로 변경됨.


    args(0x100) -----------------> | "10" | "홍길동" | "3.14"  |
                                      0        1        2
//////////////////////////////////////////////////////////////////////////
  * 이클립스에서 실행시 배열값을 설정하는 방법

     파일선택 > 오른쪽 클릭 > Run As.. > Run Configurations > Arguments 탭 선택 > 
     Program arguments 항목에 10 홍길동 3.14 값을 입력한다.

     또는
      Program arguments 항목 > Variable 선택 > string_prompt 선택 > 실행


    공백으로 구분된 여러값을 하나의 문자열로 만들기 위해서는 "10 홍길동"  3.14 처럼 "" 이용해서 묶어준다.
//////////////////////////////////////////////////////////////////////////

4. 2차원 배열 ( array )

  1) 개념
    1차원 배열: 하나의 행을 가진 배열 의미.
             layer가 하나가 있음을 의미.

       예>
            num(0x100) -------------------> |10|20|

    2차원 배열: layer가 2개가 있음을 의미.
        
	 (배열명)                            행배열([])               열배열([])
          num(0x100) -------------------> |0x10|Ox20| -----------> 0x10
	                                                           |10|20|

                                                      -----------> 0x20
	                                                           |30|40|

  2) 문법1 - new 이용
 
      가. 정방형 : 배열생성시 열의 크기가 동일
         
	  int [][] num; // 2차원 배열선언

	  num = new int[2][2]; //  2차원 배열 생성 , [행크기][열크기]
 
                           행크기            열크기
          num(0x100)----> |Ox10|Ox20| --> | 0      |  0  | (Ox10)
                            0     1        X[0]      X[1]
                          num[0] num[1]    num[0][0] num[0][1]
			    X     Y
                                       --> | 0     | 0 |  (Ox20)
                                           num[1][0] num[1][1] 
         2차원 배열의 첫번째 행 참조? num[0] 
         2차원 배열의 행 길이? num.length

         2차원 배열의 1행 1열 참조?  num[0][0]
         2차원 배열의 2행 열 길이?  num[1].length

      나. 비정방형: 배열생성시 열의 크기가 다른 경우


  2) 문법2 - 리터럴 이용
  2) 문법3 - new + 리터럴 이용

/////////////////////////////////////
4일차 리뷰

 1. 1차원 배열 ( array )
   
   1)목적
     - 데이터 저장
   2)특징
     - 동일한 데이터만 저장가능
     - 크기가 변경이 불가
     - 존재하지 않는 요소를 접근할 경우 ArrayIndexOutofBoundsExcetion 예외가 발생된다.
   3)문법1- new 이용
   
     main(){
       int [] num; // num은 로컬변수, 데이터타입은 int [](배열) 임. 참조형 변수(주소값을 저장하는 변수)
                   // stack 메모리에 생성

       num = new int[3]; // new 는 heap 메모리에 생성, heap 메모리에 생성된 경우는 자동초기화 됨.

       //초기화
       num[0]=10;
       num[1]=20;
       num[2]=30;
     }
 
     문법2- 리터럴 이용 ( 가장 많이 사용됨 )
       int [] num = {10,20,30};

     문법3- new+리터럴

       int [] num;
       num = new int[]{10,20,30};  // 크기 지정 불가

  4) 배열 순회

    가. index 명시적으로 지정
    나. for(int idx=0; idx<num.lenght; idx++){} 
       => 일반 for문은 조건식을 잘못 지정하면 ArrayIndexOutofBoundsExcetion 예외 발생 확률이 높아짐.

    다. foreach 문
       for(변수: 배열){

       }
      => 조건식이 없기 때문에 ArrayIndexOutofBoundsExcetion 예외 발생 확률이 없다.

   5) main(String [] args) 사용 용도

     문법: java Test 값  값1  값2 .. 

     예> java Test 10 20

   6) 문자열숫자를   정수로 만드는 방법
   
      int n = Integer.parseInt("10");


2. 2차원 배열


