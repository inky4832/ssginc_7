
강사명: 인경열
이메일: inky4832@daum.net


1. 회원가입
 
  - 구글
  - github
  - 오라클
    http://www.oracle.com

2. 환경설정

  1) JDK ( Java Development Kit ) 설치
    - C:\Program Files\Java\jdk-17 에 기본적으로 설치됨.
    - 환경변수 설정
      시작 > 마우스 오른쪽 클릭 > 시스템 > 고급 시스템 설정 > 고급 탭 > 환경변수 

      JAVA_HOME=C:\Program Files\Java\jdk-17  <=== JDK의 홈디렉터리 경로 설정
      PATH=%JAVA_HOME%\bin;기본PATH                                   <=== 윈도우의 프로그램에 명령어 경로 설정
           C:\Program Files\Java\jdk-17\bin;기본PATH   

      * 주요 명령어 2개

       javac.exe ( 컴파일하는 명령어, 컴파일러(compiler) 라고 부름 )

       java.exe  ( 실행하는 명령어,  인터프리터(interpreter) 라고 부름 )


      * 자바 실행 순서

      소스 파일( *.java 예> Test.java )
         |
      컴파일 작업 ( 컴파일러 이용: javac.exe )
                
		문법:  javac Test.java  <=== Test.class 파일이 생성됨 

         |
      실행 작업 ( 인터프리터 이용: java.exe )

                문법:  java Test        <=== Test 클래스가 실행되어 결과가 나옴.


      * JDK 설치시 설치되는 JVM ( Java Virtual Machine )


         *.class
        -------------
         JVM 
        --------------
          OS ( Window, Linux, Mac )
         -------
	   H/W
   
       JDK ( Java Development Kit     : 자바개발 환경 ) <==== 실제로 자바어플리케이션 개발하는 개발자 환경
                                                          JRE +  API + 개발도구( javac, ... ) 

       JRE ( Java RunTime Environment : 자바실행 환경 ) <==== 실제로 자바어플리케이션을 실행하는 일반 사용자 환경.
                                                          JVM + API

       자바 API : 자바에서 미리 만들어서 제공된 클래스 파일들을 의미.
                압축해서 제공됨. ( *.jar 형식 )
             
	       C:\Program Files\Java\jdk-17\lib\src.zip 파일이 API의 소스파일.

             * 자바의 압축 파일 3가지
  
               -jar
	         => 일반적인 SE 환경의 압축파일
                    예> *.jar
	       -war
	         => 일반적인 EE 환경의 압축파일
                    예> *.war
	       -ear
                 => jar + war 환경의 압축파일
                    예> *.ear

      자바 API 문서 :  어떤 자바 API가 있는지 알려주는 메뉴얼.
                    웹으로 제공됨.
           https://docs.oracle.com/en/java/javase/17/docs/api/index.html



   2) 개발툴 ( IDE )
     - 인텔리제이 (
       http://www.jetbrains.com

     - 이클립스
       http://www.eclipse.org
       인스톨 프로그램 아님. 압축 풀면 설치됨.
       C:\java_study\eclipse\workspace 생성  > eclipse.exe 실행
       
       eclipse 실행후 추가작업
        가. 한글 인코딩 설정 (utf-8)
           elcipse의 window항목 > preference > General > workspace 에서 Text File Encoding 에서
	   UTF-8로 설정.

	나. 글꼴 설정
	   elcipse의 window항목 > preference > General > Apper~ > Color&Fonts > Basic > Text Font 에서 설정

        다. 컴파일러 버전 변경
            elcipse의 window항목 > preference > Java > Compiler 에서 현재 21 --> 17로 변경.

        라. JRE 변경

	    elcipse의 window항목 > preference > installed JRE > 기존 JRE 삭제.

3. 자바 특징
  - OOP( Object Oriented Programming )
  - 플랫폼 독립적 ( OS 독립적 )
    가능한 이유가 JVM 덕분이다.
  - 개발자가 더 이상 메모리를 관리하지 않는다. ( GC: Garbage Collector )
    GC가 메모리에 있는 사용되지 않는 인스턴스(클래스가 메모리에 올라간 상태)를 자동으로 제거한다.

4. 자바 개발 환경 3가지 ( 기준: 디바이스(장치))

   1) Java SE ( Java Standard Edition )
      - 일반 PC 	
      - 자바 기술
      - 구축방법: JDK 설치

   2) Java EE ( Java Enterprise Edition )
      - 서버(웹 서버)
      - 웹페이지 개발 기술 ( Servlet & JSP )
      - 구축방법: Tomcat 설치

   3) Java ME ( Java Micro Edition )
      - 휴대용 장치 ( PDA, 셋탑박스 )


5. 이클립스 프로젝트 생성

  - module 는 체크 안함 (****************)
  
6. 자바 클래스 작성 ( *.java )

   - 반드시 첫글자는 영문자이고 또는 _ (언더바) 또는 $ 만 가능하다.
     이후에 숫자지정은 가능.
   
   - 대소문자 구별됨.
   - 특수문자는 _ (언더바) 또는 $ 2개만 가능.
   - 한글은 가능하지만 권장안함.
   - 자바클래스 첫글자는 반드시 대문자로 지정한다. ( 권장 )
  
   - 문법:
   
        public class 클래스명{
          
	    //구성요소 3가지
	    // 1. 변수
	    // 2. 생성자
	    // 3. 메서드

	}

   - 반드시 지정된 클래스명으로 파일을 저장해야 된다. ( 클래스명.java )
   - 자바에서는 클래스가 프로그램의 최소 단위이다.
     매우 비효율적이다. 따라서 함수형 프로그래밍이다.( 클래스 없이 메서드 사용 가능) 
     람다(lambda) 표현식이라고 부름. (****************)

7.  main 메서드

   - 하나의 자바 어플리케이션을 작성할때 반드시 존재하는 메서드임. (*************)
   - main 메서드 역할은 실행하기 위함이다. 즉 프로그램의 시작점 역할 담당 ( starting point )
     반드시 다음 문법을 따라야 된다.
     public static void main(String [] args){}


   * 최종 샘플 코드

   public class HelloTest {
	public static void main(String[] args) {

		System.out.println("Hello World");
	}
 
    }

   클래스는 몇개 일까요 ?  3개
   HelloTest.class ( 개발자가 직접 만든 클래스 )
   String.class    ( API ) 
   System.class    ( API )


8. 이클립스 단축키 (********)

   - 저장: ctrl + s
   - 단일문장 주석: ctrl + /
   - 한줄 복사: ctrl + alt + 화살표키
   - 줄바꿈: alt + 화살표키
   - 한줄 삭제: ctrl + d
   - 이전 작업 취소: ctrl + z
   - sysout + ctrl + spacebar 하면 자동으로 System.out.println() 생성.
   - 코드 자동 완성: ctrl + spacebar


9. 식별자 ( identifier )

  1) 개념
     자바소스에서 지정한 단어.

  2)식별자 지정 문법
   - 반드시 첫글자는 영문자이고 또는 _ (언더바) 또는 $ 만 가능하다.
     이후에 숫자지정은 가능.
   - 대소문자 구별됨.
   - 특수문자는 _ (언더바) 또는 $ 2개만 가능.
   - 한글은 가능하지만 권장안함.
   - 자바클래스 첫글자는 반드시 대문자로 지정한다. ( 권장 )

     public class 클래스명{
          
	    //구성요소 3가지
	    // 1. 변수
	    // 2. 생성자
	    // 3. 메서드

	}

    클래스명 권장방법: 첫글자 대문자, 의미있는 명사형
    변수 권장방법: 모두 소문자, 의미있는 명사형
    생성자: 반드시 클래스명으로 지정해야 된다.
    메서드 권장방법: 모두 소문자, 의미있는 동사형

  3) 식별자 종류 

    가. 시스템이 미리 예약한 식별자 ( 시스템 정의 식별자 )
       - 예약어(키워드) 라고 부른다.
        예> public,protected,private,class,interface,
	   abstract,final,default, switch, for, if,
	   transient,void, enum,.....

    나. 사용자 정의 식별자
       - 클래스,변수,메서드 식별자가 됨.
       - 시스템 정의 식별자(예약어) 이름으로 지정하면 안됨.

   
   * 리터럴 ( literal )
     - 자바코드상에서 사용된 데이터 (값 ) 의미.
     예> 문자열 데이터 :   "홍길동",  "hello"
                   반드시 쌍따옴표 지정.

        문자 데이터 :  '남', '여'
                   반드시 홑따옴표 지정.
	정수 데이터 : 100
	실수 데이터 : 3.14
	논리 데이터 : 참/거짓
	          true/false

    ==> 자바는 문자열과 문자를 다르게 처리한다. (*********)

 * 괄호
  (): 소괄호
  {}: 중괄호
  []: 대괄호


10. 데이터 종류 ( 데이터 타입, 데이터형 )- (********************************)
  - 개념: 자바언어가 처리할 수 있는 데이터 종류 의미함.

  1) 기본형 데이터 ( Primitive Data Type: PDT )
     - 수치형 데이터
              - 정수:  byte ( 크기: 1byte, 8bit )
	             short ( 크기: 2byte, 16bit )
		     int   ( 크기: 4byte, 32bit )- 기본
		     long  ( 크기: 8byte, 64bit )
                    
		   정수 표현:  10진수,2진수,8진수,16진수 모두 표현 가능.
		    예> 10진수: 0~9 이용해서 표현
		              100, -30, 0
                       2진수: 0|1 이용해서 표현, 접두사로 0b 지정
		             0b1, 0b0
		       8진수: 0~7 이용해서 표현, 접두사로 0 지정
		             01,02,.....07
                       16진수: 0~9, A,B,C,D,E,F 이용해서 표현, 접두사로 0x 지정
		             0x1,0x2,.....0xE, 0xF

	      - 실수:  float ( 크기: 4byte, 32bit )
	             double ( 크기: 8byte, 64bit )- 기본

                  float 표현:  3.14F, 3.14f
		  double 표혐: 3.14 , 3.14D, 3.14d

      - 문자:   char 이용 ( 2byte ). 기본형 타입이다.
           반드시 ''(홑따옴표) 이용해서 표현
	   예> '남',  'A'
           이스케이프 문자도 지원한다.
	   예> \t : 키보드 tab 효과
	      \n : 키보드 enter 효과
	      \" : " 를 출력
              \' : ' 를 출력 
	      \\ : \ 를 출력
           
	  유니코드(unicode)로 처리되기 때문에 전 세계의 모든 언어 표현이 가능하다.
	  유니코드는 \u값 으로 표현된다.

     - 논리 데이터 : boolean (불린) ( 크기: 1byte, 8bit )
               
                 boolean 표현:  true (참)
		              false (거짓)
    
  ==> 기본형은 총 8개.

  2) 참조형 데이터 ( Reference Data Type: RDT )
     - 기본형 8가지가 아닌 나머지 모두.
      대표적으로 클래스,배열,인터페이스 가 있음.
      반드시 클래스,배열,인터페이스를 데이터로 간주하자.(*************)
//////////////////////////////////////////////////////////////////
1일차 리뷰

1. 자바 3가지 환경

   Java SE: 기본개발환경, JDK 설치, 2가지 환경변수 설정 ( JAVA_HOME, PATH )
   Java EE: 웹 개발 환경 ( Servlet/JSP ), Tomcat 설치
   Java ME: 휴대용 모바일 환경

2. 자바특징
   - OOP(Object Oriented Programming) :객체 지향 프로그래밍 방법론
     나중에 함수형 프로그래밍(자바에서는 람다(lambda)라고 부름)과 AOP(Aspect Oriented Programming: 관점 지향 프로그래밍)
     방법론을 배운다.
   - 플랫폼에 독립적 ( 어떤 OS건 한번 만든 자바 어플리케이션을 바로 실행이 가능하다. )
     플랫폼에 의존적인 언어도 있음( C언어 )
   - 자동으로 사용하지 않는 메모리에 올라간 인스턴스를 제거해줌. Garbage Collector(GC)가 해줌.
     결국 자바 개발자는 메모리 관련되서 신경쓸 필요가 없다.

3. 자바 개발 순서

   1)소스작성 ( Hello.java )
     
   2)컴파일
     - 컴파일러 이용해서 컴파일 한다. ( javac.exe )
     - 문법:  javac Hello.java

        Hello.java ---------------> Hello.class ( bytecode 라고 부름 ) 

   3)실행
     - 인터프리터 이용해서 실행 ( java.exe )
     - 문법:  java Hello
  
         Hello.class ------------------> 결과 출력

4. JVM ( Java Virtual Machine )

  - 역할: bytecode 를 실행하는 역할.
  - 구축방법: JDK 설치
  - H/W 느낌이 나지만 명백한 S/W 임.
   그런데 H/W 특징을 가짐 ( 다양한 메모리를 가짐 )
  - 주요 메모리 3가지: stack, heap, method area (******************)

5. 자바의 데이터종류 ( 데이터타입, 데이터형 )

  1) 기본형 데이터 ( Primitive Data Type :PDT )
  
      - 수치형 
             정수형 : byte  ( 1byte )
	            short ( 2byte )
		    int  ( 4byte ) - 기본 ( 만약 100 이라고 지정하면 int로 처리됨 )
		    long ( 8byte )
                   
		   - 10진수,2진수,8진수,16진수 표현 가능.

	     실수형 : float ( 4btye )
	            double ( 8byte ) - 기본 ( 만약 3.14 이라고 지정하면 double로 처리됨 )

		    float 표현: 3.14F, 3.14f
                    double 표현: 3.14, 3.14D, 3.14d

		    지수 표현 가능: 140.0 는 1.4E2로 표현 가능.

      - 문자형 : char ( 2byte )
               유니코드로 처리되기 때문에 전세계의 모든 언어 표현 가능.

      - 논리형 : boolean ( 1byte)
               true/false


  2) 참조형 데이터 ( Reference Data Type :RDT )

     - 기본형 8개를 제외한 나머지가 모두 참조형이다.
      대표적으로 클래스, 배열, 인터페이스가 있다.

///////////////////////////////////////////////////////////
2일차

1. int 와 long 

   - int 는 정수형의 기본타입이다.
     즉 만약 100 이라고 지정하면 int로 처리됨.

   - 만약 long 으로 처리하고자 한다면
      100L 형식으로 표현한다.
   
2. 문자와 문자열

  - 기본적으로 자바는 문자와 문자열을 다르게 처리한다.
  - 문자:   char 이용. 기본형 타입이다.
           반드시 ''(홑따옴표) 이용해서 표현
	   예> '남',  'A'
           이스케이프 문자도 지원한다.
	   예> \t : 키보드 tab 효과
	      \n : 키보드 enter 효과
	      \" : " 를 출력
              \' : ' 를 출력 
	      \\ : \ 를 출력
           
	  유니코드(unicode)로 처리되기 때문에 전 세계의 모든 언어 표현이 가능하다.
	  유니코드는 \u값 으로 표현된다.


    문자열:  String 클래스 이용, 참조형 타입이다.
           반드시 ""(쌍따옴표) 이용해서 표현
	   예> "남자",  "ABC"


3. wrapper 클래스 

 - 개념: 기본형 8개에 해당되는 8개의 클래스(API)를 묶어서 표현하는 이름.

  기본형              wrapper 클래스(참조형)
-----------------------------------
  byte		    Byte
  short             Short
  int               Integer
  long              Long

  float             Float
  double            Double

  char              Character

  boolean           Boolean


- API로 wrapper 클래스를 제공하는 이유: 기본형 데이터를 사용할 때 여러가지 정보 및 가공(동작)처리를 원활하게 할수 있도록 지원.
 
  예>  3.14 -----> 3 
       3---------> 3.0
      int(4byte)에 저장 가능한 정수크기?


4. 변수 ( Variable )

  1) 용도
    - 데이터(리터럴)를 저장.
    - 기본형 8 개 및 참조형(클래스,배열,인터페이스)도 변수에 저장할 수 있음.

  2) 기본 문법-1

     가. 변수 선언
        - 데이터가 저장될 영역 확보 작업
	- 문법:
	   
	     데이터형  변수명;

           예> 
	       // 기본형 타입
	       byte n;  // 1byte크기의 영역확보, 그 영역은 n 으로 접근.
	       short n2; // 2byte크기의 영역확보, 그 영역은 n2 으로 접근.
	       int n3;
	       long n4;
	       float f;   // 4byte크기의 영역확보, 그 영역은 f으로 접근.
	       double f2;  // 8byte크기의 영역확보, 그 영역은 f2으로 접근.
	       char c;     // 2byte크기의 영역확보, 그 영역은 c으로 접근.
	       boolean b;  // 1byte크기의 영역확보, 그 영역은 b으로 접근.

               // 참조형 타입
	       String s;  // 무조건 4byte크기의 영역확보, 그 영역은 s으로 접근.
               Byte s2;   // 무조건 4byte크기의 영역확보, 그 영역은 s2으로 접근.


     나. 초기화

       - 변수에 맨 처음 값을 저장하는 것을 의미.
         반드시 저장되는 값은 변수의 데이터형과 일치해야 된다.
       - 문법:
          
	     변수명 = 값;

          예>  int n3;
	      char c;
	      String s;

	      n3= 10;
	      c = '남';
	      s = "홍길동";

      
     다. 값변경 및 사용(출력)

            n3 = 20;
	    c = '여';

	   System.out.println(n3);
	   System.out.println(c);
	   System.out.println(s);

   2) 기본 문법-2

      - 변수선언과 초기화를 한꺼번에 지정 가능

      - 문법:

          데이터타입 변수명 = 값;

       예> 
           int n = 10;
	   char c = '남';
	   String s = "홍길동";

   2) 기본 문법-3

     - 같은 타입의 변수가 여러개 일 때 사용 가능. 권장안함

      예>
          int n;
	  int n2=10;
	  int n3;

      ==> int n,n2=10,n3;  ( 권장안함)


5. 변수의 종류-1 (*************)
  
   1) 데이터 종류에 따라서 분류

    가. 기본형 변수
       - 기본형 데이터가 저장된 변수

       예> int n = 10;  // n은 변수
                          n은 int 타입의 변수
			  n은 정수형 변수
			  n은 기본형 변수
          char c = '남'; // c은 변수
	                   c는 char 타입의 변수
                           c는 문자형 변수
                           c는 기본형 변수

       - 기본형 변수는 변수에 실제 데이터가 저장되어 있음 (*******)
 
    나. 참조형 변수
       - 참조형 데이터가 저장된 변수

       예> String s = "홍길동";  // s는 변수
                                 s는 String 타입의 변수  
                                 s는 문자열 타입의 변수
				 s는 참조형 변수

       - 참조형 변수는 변수에 실제 데이터가 저장되어 있는 주소값이 저장되어 있음 (*******)
         즉 클래스,배열,인터페이스 타입의 변수는 참조형 변수이기 때문에 주소값이 저장되어 있다. (*******)

5. 변수의 종류-2 (*************)

   - 변수 선언 위치와 용도에 따른 분류

   1)로컬 변수     ( local variable, 지역변수)
    - 변수선언위치:  메서드 안에서 선언된 변수
    - 생성시점:  메서드 실행 ( 메서드는 호출해야 실행이 된다. )
      소멸시점:  메서드가 끝날때
    - 저장메모리: stack 메모리
    - 생성횟수: 메서드가 호출해서 실행될때 마다 매번 생성
             메서드가 끝나면 매번 제거됨.
    - 용도: 일시적으로 임의의 데이터 저장하기 위해서 주로 사용됨.
    - 주의할 점: 반드시 사용하기 전에 초기화해야 된다.

   2)인스턴스 변수  ( instance variable )
    - 변수선언위치:  메서드 밖에서 선언된 변수
    - 생성시점: 클래스를 객체 생성할 때 ( 클래스 객체 생성는 new 키워드 이용)
      소멸시점: 메모리에 올라간 객체(인스턴스)가 소멸될 때
    - 저장메모리: heap 메모리
    - 생성횟수: 객체생성할때 마다 매번 생성됨.
    - 용도: 객체의 속성을 저장할 때 사용.
    - 초기화하지 않으면 자동으로 초기화 된다.
       기본형 데이터:  정수: 0
                   실수: 0.0
		   문자: \u0000  ( 빈문자)
		   논리: false
		   
       참조형(클래스,배열,인터페이스) 데이터: null

   3)클래스 변수    ( class variable, static variable )
    - 변수선언위치:  메서드 밖에서 선언된 변수 + static 키워드 지정
    - 생성시점: 프로그램 실행시 생성
      소멸시점: 프로그램 종료시 제거
    - 저장메모리: method area 메모리
    - 생성횟수: 1 번만 생성됨.
    - 초기화하지 않으면 자동으로 초기화 된다.
    - 초기화하지 않으면 자동으로 초기화 된다.
       기본형 데이터:  정수: 0
                   실수: 0.0
		   문자: \u0000  ( 빈문자)
		   논리: false
		   
       참조형(클래스,배열,인터페이스) 데이터: null

6. 변수의 특징

  - 같은 이름으로 선언 안됨.
    이유는 식별이 불가능하기 때문이다.

  - 로컬변수는 반드시 사용전에 초기화 해야 된다. ( 컴파일 에러 발생 )

  - 선언된 변수를 인식하는 범위(scope)는 블럭단위( {} ) 이다. (****************)
   자바는 블럭 scope를 따른다.
   자바스크립트는 함수 scope를 따른다.
   

7. 상수
 
  - 값 변경이 불가
  - 문법:
   
     final 데이터타입 상수명=값;   // 초기화 된 값은 변경이 불가

  - 변수와 구별하기 위해서 상수명은 대문자로 지정한다.
    단어와 단어사이는 _(언더바) 사용.

   예> Byte.MIN_VALUE

  - 일반적인 상수는 public static final 키워드를 지정해서 사용한다. ( 관례 )


8. 데이터 타입 변환 (데이터형 변환 )

  1) 개념
    서로 다른 데이터타입(데이터형)이 프로그램 실행중에 원래의 데이터형을 버리고
    새로운 데이터 형으로 변경되는 것을 의미한다.
    예> int--->byte
       byte-->int
       int --> float
       
  2) 형변환 방법

     가. 명시적 형변환 ( 강제 형변환, type casting, down-casting )
        - 일반적으로 의미하는 형변환을 말함.
        - 형변환 연산자 이용

	 문법: 
	      작은타입 = 큰타입;  //에러
              작은타입 = (작은타입)큰타입;  // 형변환
          예>
	      int n = 10;
	      short s =  n; //에러
	      short s =  (short)n; // 형변환

	 - 데이터 손실이 발생될 수 있음.

     나. 묵시적 형변환 ( 자동 형변환, promotion, up-casting )

       a.  byte > short > int > long > float > double , 역은 에러 발생됨.
       b.  char > int  ( 아스키코드 )
          예> 'A'--> 65
	     'a'--> 97

	  내부적으로 char가 연산이 가능하다.

      c. int 보다 작은 데이터형의 연산결과는 int로 반환된다.
      d. 작은 데이터와 큰 데이터의 연산결과는 큰데이터형으로 반환된다.
        예> 정수 + 실수 ==> 실수
 
      e. 출력할 때 문자열과 비문자열을 + 하면 문자열로 반환된다. ( 연결되어 문자열로 반환됨 )
       
        예>  "hello"+1  =====> hello1

   3) 데이터형변환은 기본형 데이터뿐만 아니라
      참조형 데이터인 클래스도 형변환(명시적/묵시적) 될 수 있다. (***************************)

      예> String s = "hello";
         Object s2 = s;   // String 인 s가 Object 형으로 자동 형변환 됨.

9. 표준 출력 ( standard output )

        입력(input)                 출력(output)  => I/O
   외부 ----------> 자바프로그램(기준)------------> 외부
  (소스)                                      (목적지) 
 - 키보드(표준입력)                              - 모니터(표준출력)
   파일                                         파일
   네트워크                                      네트워크

  1) 개념
    표준 출력인 모니터에 데이터를 출력하는 방법.

  2) 방법 3가지

   가. System.out.println(값);
      - 반드시 값은 하나만 지정가능.
        만약에 여러값을 지정하려면 하나의 값으로 만들어야 된다. + 이용.
      - 여러번 사용시 새로운 줄에 출력이 된다.

   나. System.out.print(값);
     - 반드시 값은 하나만 지정가능.
       만약에 여러값을 지정하려면 하나의 값으로 만들어야 된다. + 이용.
     - 여러번 사용시 동일한 줄에 출력이 된다.
       즉 줄 변경이 안됨.


   다. System.out.printf("형식문자", 값, 값2, ... );   // 가변인자 라고 부르고 갯수는 정해져 있지 않음.
      문법: printf(String format, Object... args)

     - 형식문자(%표현식)의 갯수와 값의 갯수가 일치해야 된다.
      https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Formatter.html#syntax

      문자열: %s
      정수: %d
      실수: %f
      문자: %c
      논리: %b

      예> System.out.printf("%s", "홍길동");
         System.out.printf("%d", 100);
	 System.out.printf("%b", true);
	 System.out.printf("%f", 3.14);

	 System.out.printf("%s, %d, %b", "홍길동", 20, true);

 실제로는  System.out.printf("이름: %s, 나이:%d, 결혼여부:%b", "홍길동", 20, true);
       
    - 여러번 사용시 print 와 동일하게 한 줄로 출력이 된다.

////////////////////////////////////////////////////////////////////////////
1,2 일차

1. 자바의 데이터 종류

   1)기본형(primitive data type: PDT)
     
      -수치형: 
          정수형: byte ( 1byte )
	        short( 2byte ) 
		int  ( 4byte ) - 기본
		long ( 8byte )
             
              표현식: 10진수, 2진수(0b), 8진수(0), 16진수(0x)
	      long 타입으로 표현할 때는 100L 사용한다. 

	  실수형: float ( 4byte )
	        double ( 8byte ) - 기본
           
	   표현식: 소수점으로 표현, 지수표현 가능
	        float: 3.14F, 3.14f
                double: 3.14, 3.14D, 3.14d


      -문자형(수치형) : char (2byte)
                   유니코드이기 때문에 전세계의 모든 언어 표현이 가능.
		   escape 문자 지원 ( \t,\n,\",\',\\ )
               표현식: '홍', '남'
	       * 자바는 문자와 문자열을 구분해서 처리한다.
                 문자열을 String 클래스로 관리한다.
		 자바스크립트는 문자와 문자열을 구분 안함.

      -논리형: boolean ( 1byte )
           표현식: true/false
           
	   자바스크립트는  true/false 및 임의의 값도 논리형으로 사용이 가능하다.
	   예> 0,"",null,undefined,NaN    ==> false 로 처리
	      100  ==> true 로 처리
            

   2)참조형(reference data type: RDT)

     - 기본형 8개 제외한 나머지.
      대표적으로 클래스, 배열, 인터페이스 이다.


2. 변수 ( variable )

 1)용도: 데이터 저장
 2)문법:
        데이터형 변수;  // 변수에 지정된 데이터형만 저장이 가능하다.
	변수=값;

	데이터형 변수=값;

        자바스크립트는 변수선언시 데이터형을 지정하지 않는다.

 3)특징
   - 변수명은 유일.
   - 변수에 저장되는 값은 하나. ( 만약에 여러값이면 하나로 만들어야 됨)
   - 변수 scope는 블럭 scope이다. ( {} )
     자바스크립트는 함수 scope 이다.

 4)종류1
  - 어떤 데이터를 저장했는지 여부

   가. 기본형 변수
      - 기본형 8개를 저장한 변수.
      - 변수에 가면 실제값이 있음.

   나. 참조형 변수
      - 클래스, 배열, 인터페이스를 저장한 변수
      - 변수에 가면 실제값이 없고 실제값이 저장된 주소값을 가짐.

 4)종류2
  - 변수 선언 위치에 여부

    가.로컬변수
      -선언위치: 메서드안에서
      -생성시점: 메서드 호출
       삭제시점: 메서드가 종료
      -메모리: stack
      -특징: 반드시 사용전에 초기화 ( 컴파일 에러 )
 
    나.인스턴스변수
      -선언위치: 메서드밖에서
      -생성시점: 객체생성( new )
       삭제시점: 객체소멸
      -메모리: heap
      -특징: 변수가 자동 초기화 됨.
            정수: 0
	    실수: 0.0
	    문자: \u0000 (빈문자)
	    논리: false

	    참조형:null

    다.클래스변수(static변수)
      -선언위치: 메서드밖에서 + static 지정
      -생성시점: 프로그램 실행
       삭제시점: 프로그램 종료
      -메모리: method area	 
   -특징: 변수가 자동 초기화 됨.
    정수: 0
    실수: 0.0
    문자: \u0000 (빈문자)
    논리: false

    참조형:null

3. 데이터형 변환

   가. 묵시적형변환
      - byte > short > int > long > float > double
      - char > int
      - 작은 데이터와 큰 데이터 연산 ==> 큰 데이터 형
      - int 보다 작은 데이터의 연산 ==> int
      - 문자열 + 비문자열 ==> 연결되어 문자열로

   나. 명시적형변환
      - (타입)

  ==> 기본형 및 참조형에서도 데이터형 변환이 가능하다. (***********)

4. 표준 출력
 - 모니터에 값 출력 의미

  가. System.out.println(값)
  나. System.out.print(값)
  다. System.out.printf("형식문자", 값, 값2,.... ) <== 가변인자임. ( ... )

///////////////////////////////////////////////////////////////////////
3일차

1. 연산자 ( operator )

  가. 산술연산자

   값1 + 값2
   값1 - 값2
   값1 * 값2
   값1 / 값2
   값1 % 값2 (나머지)

 # + 값이 산술연산자가 아닌 연결연산자로 사용되는 경우도 있다.
  => 문자열 + 비문자열 결과는 연결되어 문자열로 반환된다.
  예> "hello"+1+2 ==> "hello12"

  나. 대입연산자
     용도: 변수에 값을 할당(대입)하는 역할

     변수 = 값;
     a = b;   // a 에 b값을 할당(대입)

    변수 += 값;
     a += b;  // a = a + b; 동일 

     a -= b;  // a = a - b; 동일 
     a *= b;  // a = a * b; 동일 
     a /= b;  // a = a / b; 동일 
     a %= b;  // a = a % b; 동일 

  다. 비교연산자
   용도: 값(기본형)을 비교하는 기능
       (참조형은 클래스,배열,인터페이스이기 때문에 비교연산자를 사용하는 경우는 거의 없다. )
   특징: 실행결과는 항상 논리형으로 반환됨. ( true/false)

   a == b;  // a 와 b 가 같냐?
   a != b;  // a 와 b 가 같지 않냐?
   a > b;  // a 가 b 보다 크냐?
   a >= b;  // a 가 b 보다 크거나 같냐?
   a < b;   // a 가 b 보다 작냐?
   a <= b;  // a 가 b 보다 작거나 같냐?

   -자바스크립트에서는  === , !==  연산자가 더 있음.
   -만약에 참조형변수를 == 하면 주소값 비교가 된다.

     예> 참조형변수1 == 참조형변수2 는 주소값 비교가 됨.

   - 문자열 비교시에는 절대로 == 사용하면 안됨. (******************)
    예> String s = "홍길동";
       String s2 = "홍길동"; 
 
       //  문제: s와 s2가 같냐?
       System.out.println( s == s2 ); // 절대로 사용하지 말것. 실제 홍길동 값이 아닌 주소값을 비교하는 코드이다.

       System.out.println( s.equals(s2) ); // 실제 홍길동값을 비교하는 코드이다.


  라. 논리 연산자
  
    용도: 논리값(true/false)을 이용해서 연산하는 기능.
    특징: 실행결과는 항상 논리형으로 반환됨. ( true/false)

     &&: and (그리고) 해석,  and 연산자

       논리값1 && 논리값2 <== 논리값1 과 논리값2 가 모두 true인 경우에만 최종적으로 true 가 반환됨.
                          하나라도 false 인 경우에는 최종적으로 false 가 반환됨.
     
     ||: or ( 또는 ) 해석,  or 연산자

       논리값1 || 논리값2  <== 논리값1 과 논리값2 중에서 하나라도 true인 경우에는 최종적으로 true 가 반환됨.
                           모두 false 인 경우에는 최종적으로 false 가 반환됨.

     ! : not (부정) 해석,   not(부정) 연산자

       !논리값

 
    - 실제로는 논리값(true/false)를 사용하지 않고 실행결과가 논리값으로 반환되는 연산자(비교연산자)를
      사용하는 것이 일반적이다.

      예>  true && false

          int n = 10;
	  (n > 20) && (n < 10)

    - 여러개의 논리값 사용 가능
     예> 논리값1 && 논리값2 || 논리값3 ...

    - short circuit logical 연산자로 동작됨.
     연산자의 앞의 논리값만 확인해서 실행결과가 정해지면
     두번째 논리값은 실행되지 않고 최종적인 결과가 반환되는 매커니즘 의미.

  마. 증감 연산자 ( 증가 연산자 와 감소 연산자 )

    용도: 값을 1씩 증가 또는 1씩 감소하는 기능.

    문법:
         a. 증가 연산자
	    
	    ++변수명;    // 전치 연산자, 변수명=변수명+1; 동일,  변수명 += 1;
	    변수명++;    // 후치 연산자, 변수명=변수명+1; 동일,  변수명 += 1;

	 b. 감소 연산자

            --변수명;    // 전치 연산자, 변수명=변수명-1; 동일,  변수명 -= 1;
	    변수명--;    // 후치 연산자, 변수명=변수명-1; 동일,  변수명 -= 1;

    주의할점: 증감 연산자를 다른 연산자와 같이 사용하는 경우 실행 결과값이 달라질 수 있다.

          예>  int n = 10;


              int n2 = ++n;  // 전치는 ++ 하고 나중에 = 실행
	      int n2 = n++;  // 후치는 = 하고 나중에 ++ 실행

   바. 3항 연산자

    문법: 변수 = (조건식)?참값:거짓값;

    특징: 중첩이 가능.

        변수 = (조건식)? 3항연산자:거짓값;
	변수 = (조건식)? 참값:3항연산자;


2. 표준 입력 ( standard input )
 
  1) 개념
    키보드로 데이터를 입력 받음을 의미.
    
    키보드 의미: System.in
    모니터 의미: System.out

  2) 방법 2가지

    가. java.io 패키지의 API 이용

             입력                      출력
              
              ?                        ?
	    (byte,char)              (byte,char)
	소스 ------> 자바어플리케이션(기준) ------> 대상
      키보드                                 모니터
      파일                                   파일
      네트워크                                네트워크

     
      byte 입력: ~~~~InputStream
      byte 출력: ~~~~OutputStream

      char 입력: ~Reader
      char 출력: ~Writer

    
    나. java.util 패키지의 API 이용

      - Scanner 클래스 이용.

      a. 경로를 지정해야 한다.

        import java.util.Scanner;


      b. Scanner 클래스를 객체 생성해야 된다.
         ( 클래스를 사용할때는 반드시 객체 생성해야 된다.
	   객체생성하면 메모리에 올라갈 수 있다.
	 )
  
        문법:  클래스명  변수 = new 클래스명([값1,값2,...]);

          Scanner scan = new Scanner(System.in);

	  ....
	  scan.close(); // 마무리

      c. 데이터를 읽는 다양한 방법의 메서드 제공

        정수값으로 읽기:
                     int n = scan.nextInt();

	문자열(단어)로 읽기:

	            String s = scan.next();

		    예>
		       홍길동 이순신 

        한 줄 읽기:   String s = scan.nextLine();


 

3. 문장 (statement)

 1) 문장종류

      가. 실행문
              - 순차문: main 메서드의 첫라인부터 순차적으로 실행되는 문장.
	              거의 90% 이상 차지함.

	      - 제어문: 
	        
		   조건문(분기문):  조건식에 따라서 실행되는 문장이 달라진다.
                              종류: 단일 if문
			           if~else문
				   다중 if문  ( 동등 및 부등 이용한 경우 )
				   switch 문 ( 동등 연산 이용한 경우 )

		   반복문: 조건식에 따라서 한번 실행된 문장이 여러 번 실행될 수 있다.
                              종류: for문
			           while문
				   do~while문

      나. 비실행문
         - 자바가 실행하지 못하는 문장의미.
	 - 일반적으로 주석문이라고 부른다.

	    한줄 주석문:  // 문장
	    멀티 주석문:  /*
                         문장
	               */


  2) 조건문

    가. 단일 if문
     용도: 조건식(true/false) 결과에 따라서 문장의 실행여부가 결정되는 문장.
          즉 true 인 경우에만 실행되고 false 인 경우에는 실행이 안되는 경우.

     문법:

        a. {} (블럭) 없는 경우

	    if(조건식) 문장1; // 조건식에 따른 영향을 받음.
	                      조건식이 true 인 경우에만 문장1 이 실행됨.
	             문장2; // 조건식에 따른 영향을 안받음. 

	b. {} (블럭) 있는 경우 ( 권장 ) ==> {} 역할은 영향 미치는 문장을 묶어주는 역할.


	    if(조건식){      // 조건식에 영향을 받는 문장은 {} 전체임.
		    문장1;
	    }
	            문장2;

	     if(조건식){      // 조건식에 영향을 받는 문장은 {} 전체임.
		    문장1;
		    문장2;
	    }
	            

   나. if~else문
     용도: 조건식(true/false) 결과에 따라서 실행되는 문장이 달라지는 경우.
         true인 경우에는 if문(if블럭) 실행하고 false인 경우에는 else문(else블럭) 실행.
     문법:

        a. {} (블럭) 없는 경우

	   if(조건식)
	       문장1;
	   else  
	       문장2;

       b. {} (블럭) 있는 경우 ( 권장 )

           
	   if(조건식){ 
	      문장1; // 조건식이 true 인 경우에 실행
	   }else{
	      문장2; // 조건식이 false인 경우에 실행
	   }

  다. 다중 if문
    용도: 여러번 조건식을 이용해서 비교할 때.
  
    문법:
     
         if(조건식1){
             문장1;
	 }else if(조건식2){
             문장2;
	 }else if(조건식3){
             문장3;
	 } // 단일 if문으로 끝나는 경우

	  if(조건식1){
             문장1;
	 }else if(조건식2){
             문장2;
	 }else if(조건식3){
             문장3;
	 }else{
             문장4;
	 } // if~else문으로 끝나는 경우

  
   라. switch 문

     용도: 다중 if문 처럼 조건이 여러 개인 경우 사용됨.
     특징: 조건식에 사용되는 연산자가 없음.
          내부적으로 == 사용됨

     문법:

          switch( 변수 ){
            case 값1(리터럴): 문장1; break;
            case 값2(리터럴): 문장2; break;
	    case 값3(리터럴): 문장3; break;
            default: 문장n;		
	  }

      case에 지정하는 값의 데이터 타입은 6개만 가능하고 유일해야 된다.
       ( byte, short, int, char, String, enum )

      일치하는 case 문을 만나면 이후의 문장들은 모두 실행된다.
      만약 일치하는 문장만 실행하고 switch문을 빠져나오려면 break 키워드를 사용해야 된다. 
      즉 break 키워드는 옵션 선택이다.


  마. 조건문 사용시 특징
   
     - {} 사용하기 때문에 변수 scope 를 고려해야 된다.

      예>
          if(조건식){
	     int num= 10;

	  }
         System.out.println(num); //  에러 발생

     - 중첩 가능
     
       예>
           if(조건식){
	     ..
               if(조건식){

	       }

	  }
         
///////////////////////////////////////////////////////////////////////
4일차

1. 반복문

  예>  hello 문자열을 5번 출력하시오.

   횟수 
    1    "hello" 출력
    2    "hello" 출력
    3    "hello" 출력
    4    "hello" 출력
    5    "hello" 출력
    6    중단

    10
    9
    8
    7
    6
    5 중단

 반복문에 필요한 요소

   가. 시작값(초기값) 필요 ==> 1 또는 10 를 저장. 변수 사용
       int n = 1;
       int n2 = 10;

   나. 시작값을 증가/감소 ==> 연산자 이용
       1씩증가: n++, ++n
       1씩감소: n2--, --n2
       2씩증감: n+=2 ( n=n+2)
              n-=2 ( n=n-2)

   다. 반복을 중단하기 위한 조건식 필요
       n < 6

  
  위 3가지중에 하나라도 설정하지 않거나 잘못 설정하면
  반복이 아예 안되거나 무한루프에 빠질 수 있다.


  1) for 문
   
   문법: for(시작값(초기값) ; 조건식 ; 증감식){
	   문장1;
	   문장2;
	   ..
        }
   특징: 3가지 구성요소가 서로 뭉쳐있기 때문에 반복횟수를 예측이 가능하다.
       따라서 반복횟수가 예측이 가능한 경우에 사용된다.

  예>
      for( int n = 1  ;  n < 6  ; ++n ){
        System.out.println("hello");
      }

    
 2) while 문
  - 기본문법은 조건식만 지정한다.
   하지만 정확한 반복을 할려면 초기값과 증감식이 반드시 필요하다.
   초기값과 증감식은 적절한 위치에 설정해야 된다.
  문법:
       
       초기값;
       ...

       while(조건식){
           문장1;
	   문장2;
	   ..
	증감식;
       }
   
  특징: 3가지 구성요소가 서로 떨어져 있기 때문에 반복횟수를 예측하기가 어렵다.
       따라서 반복횟수 예측이 어려운 경우에 사용된다.
       무한루프 사용시 while문을 주로 사용된다.
       조건식이 맨 처음부터 false이면 문장을 한 번도 실행되지 못할 수도 있음.
       
       //무한루프
       while(true){
          문장1;
       }
  
  3) do~while 문
  - 기본문법은 조건식만 지정한다.
   하지만 정확한 반복을 할려면 초기값과 증감식이 반드시 필요하다.
   초기값과 증감식은 적절한 위치에 설정해야 된다.
  
  -특징:  조건식이 나중에 실행되기 때문에 적어도 한번은 무조건 문장이 실행될 수 있음.

  문법:
     
      초기값:
      ..
      do{
        문장;
        증감식;
      }while(조건식);

 
  4) 반복문의 고려사항

    - {} 가지고 있기 때문에 변수 scope 를 고려하자. 
    - 모든 제어문(조건문, 반복문)은 서로간에 중첩이 가능하다.
     예>
         if(){
	   for(){}
         }

	 for(){
	   if(){}
	 }

	 for(){
	   for()
	 }

    5)  반복문에서 사용 가능한 2가지 키워드

     가. break
       용도: (조건식이 만족하더라도)반복문을 빠져 나올때 사용.
       문법:
            for(;조건식1;){
             if(조건식2)break;  // {} 지정 안함.
             ...
           }

     나. continue

       용도: 반복해야되는 여러 문장들 중에서 특정 문장들의 실행을 skip할 때 사용.
            즉 특정 반복회차에서 skip 함.
       
       문법:

            for(;조건식1;){
               문장1;
	       if(조건식)continue;
	       문장2;
	       문장3;
           }





/////////////////////////////////////////////////////////////////////
 * 자바에서 데이터를 저장하는 방법 3가지 ( ************) 
  
   1) 변수(variable)
     - 값(데이터) 하나만 저장이 가능.
     - 변수에 저장 가능한 값의 종류 기본형 데이터(기본형 변수)도 가능하고
              참조형 데이터(참조형 변수)도 가능하다.

   2) 배열(array)
     - 여러개의 값을 저장이 가능.
     - 배열에 저장되는 데이터는 모두 동일한 데이터형이어야 됨.
     - 배열에 저장 가능한 값의 종류는 기본형 및 참조형 모두 가능하다. ( 단, 기본형 데이터는 wrapper 클래스(참조형)를 이용해서 저장한다. )
       즉 배열은 참조형만 저장이 가능하다.
       배열 자체는 참조형이다. 즉 배열에는 주소값이 저장되어 있고 주소값을 참조하면 저장된 실제 데이터가 있음.

     - 단점: 한번 생성된 배열은 크기 변경이 불가.  
            모두 동일한 데이터형만 가능. 

   3) 컬렉션(collection)
     - 여러개의 값을 저장이 가능.
     - 컬렉션에 저장되는 데이터는 모두 달라도 무관.
     - 컬렉션에 저장 가능한 값의 종류는 기본형 및 참조형 모두 가능하다. ( 단, 기본형 데이터는 wrapper 클래스(참조형)를 이용해서 저장한다. )
       즉 컬렉션은 참조형만 저장이 가능하다.
       컬렉션 자체는 참조형이다. 즉 배열에는 주소값이 저장되어 있고 주소값을 참조하면 저장된 실제 데이터가 있음.

     - 장점: 한번 생성된 컬렉션은 크기 변경이 가능. 
            데이터는 모두 달라도 무관.

     - 대표적인 3가지 컬렉션 종류 ( java.util 패키지 )
       
       가. List 계열 ( XXXList.class )
          - 저장되는 순서가 존재함.
	  - 중복데이터 저장이 가능.
	  - 대표적인 클래스는 ArrayList.class

       나. Set 계열  ( XXXSet.class )
          - 저장되는 순서가 없음.
	  - 중복데이터 저장이 불가능. ( 중복 데이터는 한번만 저장됨 )
          - 대표적인 클래스는 HashSet.class
	  
       다. Map 계열  ( XXXMap.class )
           - 저장되는 순서가 없음.
	   - 저장되는 데이터의 이름(name,key)를 같이 저장한다.
	     key/value 쌍으로 저장.
           - 대표적인 클래스는 HashMap.class
/////////////////////////////////////////////////////////////////////

2. 1차원 배열 ( array )

  1) 용도
    - 데이터 저장
   
  2) 문법-1 ( new 이용 )

      (변수,참조형변수, 배열명)
       num(0x100) --------------------> |10|20|30|40|50|
                                          0  1  2  3  4   (인덱스, 첨자)

       배열길이: num.length
       배열요소접근: num[0]
                 ..
		 num[4]
  
    가. 배열선언

        데이터형 [] 변수; // 권장    
	데이터형  변수 [] ;  

     예> int [] num;
       
        (변수,참조형변수, 배열명)
         num

   ///////////////////////////////////
    * 다음 2가지 형태를 구별해야 된다.
     
      가. int num1;  
       
         num1의 데이터 타입? ( int )
         num1에 저장되는 데이터는 ? 값이다. ( 정수형 )
	 num1의 데이터 타입은 기본형 및 참조형 중에서 ? 이다. ( 기본형 )

      나. int [] num2;

         num2의 데이터 타입?  (int [], 배열 )
         num2에 저장되는 데이터는 ? 값이다. ( 주소값 )
         num2의 데이터 타입은 기본형 및 참조형 중에서 ? 이다. ( 참조형 )

   /////////////////////////////////


   나. 배열생성 ( new 이용 )

      배열명 = new 데이터타입[크기];

     예> int [] num; // 로컬변수, stack 저장
         num = new int[5]; // heap 저장, 자동으로 초기화됨.

      (변수,참조형변수, 배열명)
       num(0x100) --------------------> |0 | 0| 0 | 0 | 0 |
                                          0  1  2   3   4   (인덱스, 첨자)

   다. 배열 요소 접근

      배열명[인덱스]; // 인덱스(index)는 0 부터 시작, 
                     인덱스(index)는 배열크기(길이) 보다 항상 1이 작음.

      num[0]=10;
      num[1]=20;
      num[2]=30;
      num[3]=40;
      num[4]=50;

     (변수,참조형변수, 배열명)
       num(0x100) --------------------> |10| 20| 30 | 40 | 50 |
                                          0  1   2    3    4   (인덱스, 첨자)


     * 요소 접근시 주의할 점
      없는 인덱스를 사용하면 에러가 발생된다.
      예>  num[5]=60; // 에러가 발생된다. java.lang.ArrayIndexOutOfBoundsException 발생됨.


    - 배열선언과 배열생성을 한번에 작성 가능

     예> int [] num = new int[5];

    - 배열요소 접근하는 3 가지 방법
      
      a. 배열명[인덱스] 사용해서 직접 요소 접근
	System.out.println(num[0]);
	System.out.println(num[1]);
	System.out.println(num[2]);
	System.out.println(num[3]);
	System.out.println(num[4]);

      b. for 문 이용

        for(int idx=0; idx < num.length   ; idx++ ){
          	System.out.println(num[idx]);
	}

      c. foreach 문 이용 ( 향상된 for문 )

        for( 변수: 배열명){
          System.out.println(변수);    
	}

	for( int n: num ){
          System.out.println(n);    
	}

 2) 문법-2 ( new 이용하지 않고 리터럴값만 이용 )
     
     배열선언과 배열생성과 초기화가 한꺼번에 이루어짐.
     따라서 한줄에 설정해야 된다.

     데이터형 [] 변수명 = { 값, 값2, ...   };

   예> //문법1
      
        int [] num;
	num = new int[2];
	num[0]=10;
        num[1]=20;

      //문법2
       int [] num = {10,20};
    
 2) 문법-3 ( 문법1(new) + 문법2(리터럴) 혼합 )

    데이터형 [] 변수;
    변수 = new 데이터형[]{값, 값2, ..}; // 명시적으로 크기지정 불가

    예> //문법1
      
        int [] num;
	num = new int[2];
	num[0]=10;
        num[1]=20;
 
        int [] num = new int[2];

       //문법2
       int [] num = {10,20};

       //문법 3
       int [] num;
       num = new int[]{10,20};

       int [] num = new int[]{10,20};

3. main 메서드의 파라미터인 String [] args 배열을 사용하는 용도

    예> Test.java
           |       <== 컴파일: javac Test.java
       Test.class
           |       <=== 실행:  java Test 값 값2 ...
         실행결과               java Test 10 홍길동  3.14

   값 값2 ... 자동으로 main메서드의 파라미터인 String [] args 에 배열로 저장이 된다.
   입력된 값은 모두 문자열로 변경됨.


    args(0x100) -----------------> | "10" | "홍길동" | "3.14"  |
                                      0        1        2
//////////////////////////////////////////////////////////////////////////
  * 이클립스에서 실행시 배열값을 설정하는 방법

     파일선택 > 오른쪽 클릭 > Run As.. > Run Configurations > Arguments 탭 선택 > 
     Program arguments 항목에 10 홍길동 3.14 값을 입력한다.

     또는
      Program arguments 항목 > Variable 선택 > string_prompt 선택 > 실행


    공백으로 구분된 여러값을 하나의 문자열로 만들기 위해서는 "10 홍길동"  3.14 처럼 "" 이용해서 묶어준다.
//////////////////////////////////////////////////////////////////////////

4. 2차원 배열 ( array )

  1) 개념
    1차원 배열: 하나의 행을 가진 배열 의미.
             layer가 하나가 있음을 의미.

       예>
            num(0x100) -------------------> |10|20|

    2차원 배열: layer가 2개가 있음을 의미.
        
	 (배열명)                            행배열([])               열배열([])
          num(0x100) -------------------> |0x10|Ox20| -----------> 0x10
	                                                           |10|20|

                                                      -----------> 0x20
	                                                           |30|40|

  2) 문법1 - new 이용
 
      가. 정방형 : 배열생성시 열의 크기가 동일
         
	  int [][] num; // 2차원 배열선언

	  num = new int[2][2]; //  2차원 배열 생성 , [행크기][열크기]
 
                           행크기            열크기
          num(0x100)----> |Ox10|Ox20| --> | 0      |  0  | (Ox10)
                            0     1        X[0]      X[1]
                          num[0] num[1]    num[0][0] num[0][1]
			    X     Y
                                       --> | 0     | 0 |  (Ox20)
                                           num[1][0] num[1][1] 
         2차원 배열의 첫번째 행 참조? num[0] 
         2차원 배열의 행 길이? num.length

         2차원 배열의 1행 1열 참조?  num[0][0]
         2차원 배열의 2행 열 길이?  num[1].length

      나. 비정방형: 배열생성시 열의 크기가 다른 경우


  2) 문법2 - 리터럴 이용
  2) 문법3 - new + 리터럴 이용

/////////////////////////////////////
4일차 리뷰

 1. 1차원 배열 ( array )
   
   1)목적
     - 데이터 저장
   2)특징
     - 동일한 데이터만 저장가능
     - 크기가 변경이 불가
     - 존재하지 않는 요소를 접근할 경우 ArrayIndexOutofBoundsExcetion 예외가 발생된다.
   3)문법1- new 이용
   
     main(){
       int [] num; // num은 로컬변수, 데이터타입은 int [](배열) 임. 참조형 변수(주소값을 저장하는 변수)
                   // stack 메모리에 생성

       num = new int[3]; // new 는 heap 메모리에 생성, heap 메모리에 생성된 경우는 자동초기화 됨.

       //초기화
       num[0]=10;
       num[1]=20;
       num[2]=30;
     }
 
     문법2- 리터럴 이용 ( 가장 많이 사용됨 )
       int [] num = {10,20,30};

     문법3- new+리터럴

       int [] num;
       num = new int[]{10,20,30};  // 크기 지정 불가

  4) 배열 순회

    가. index 명시적으로 지정
    나. for(int idx=0; idx<num.lenght; idx++){} 
       => 일반 for문은 조건식을 잘못 지정하면 ArrayIndexOutofBoundsExcetion 예외 발생 확률이 높아짐.

    다. foreach 문
       for(변수: 배열){

       }
      => 조건식이 없기 때문에 ArrayIndexOutofBoundsExcetion 예외 발생 확률이 없다.

   5) main(String [] args) 사용 용도

     문법: java Test 값  값1  값2 .. 

     예> java Test 10 20

   6) 문자열숫자를   정수로 만드는 방법
   
      int n = Integer.parseInt("10");


2. 2차원 배열 1- 정방형


  1) 문법1- new 이용
  
      int [][] num;  // 배열 선언
      num = new int[2][3];  // [2]:행크기 [3]:열크기
      ==> 모든 행의 열의 크기가 3으로 동일하다. ( 정방형 형태 )

      //초기화
      num[0][0]=10;
      num[0][1]=20;
      num[0][2]=30;
      num[1][0]=40;
      num[1][1]=50;
      num[1][2]=60;

  2) 문법2- 리터럴 이용 ( 가장 많이 사용됨 )
    
     int [][] num = { {10,20,30}, {40,50,60}};


  3) 문법3- new+리터럴
   
    int [][] num = new int[][]{ {10,20,30}, {40,50,60}};  // 행과 열크기 지정 불가


 2. 2차원 배열 2 - 비정방형 ( 각 행의 열의 크기가 다른 경우 )


  1) 문법1- new 이용

     int [][] num;
     num = new int[2][];  // 행 크기만 지정. 열은 나중에 동적으로 생성한다.

     num[0]= new int[2];
     num[1]= new int[1];

     //초기호
     num[0][0]=10;
     num[0][1]=20;
     num[1][0]=30;

  2) 문법2- 리터럴 이용 ( 가장 많이 사용됨 )

     int [][] num = { {10,20}, {30} };

  3) 문법3- new+리터럴

     int [][] num = new int[][]{ {10,20}, {30} };  // 크기지정 불가

////////////////////////////////////////
5일차

1. 클래스

  1) 객체(object) 개념
    -  주체(subject)가 보는 현실세계에 존재하는 사물.
      예> 노트북(객체)
         책상(객체)
         학생(객체)
	 고양이(객체)
	 ..

  2) 객체의 구성요소
  
     가. 속성
        - 객체를 잘 표현할 수 있는 트성
	예> 학생(객체)
	   속성: 학번, 이름, 나이, 전화번호

     나. 동작
        - 객체의 행위
	예> 학생(객체)
	   동작: 공부, 출석, 퇴실...

	   고양이(객체)
	   동작: 뛰기, 잔다,...

  3) 객체지향 프로그래밍( object oriented programming: OOP )

 
            OOP 프로그래밍 
          -------------------->
    현실세계                     가상세계( 자바 프로그램)
   -------                    --------------
   객체(사물) ------------------> 클래스
   -속성     ------------------> 변수
   -동작     ------------------> 메서드


  4) 개발 프로세스
   
   (쇼핑몰)
   개발의뢰 -----> 분석 ------> 설계 ------> 구현 ------> 테스트 ---> 최종완성 -------> 고객에게 배포

 분석단계: 객체 추출
        예> 고객(객체)
	     속성:아이디,이름,전화번호,주소,..
	     동작:이름변경,...

	   상품(객체)
	     속성:상품명,가격,...
	     동작:...

  설계단계: 고객(객체)-----------> Customer 클래스
         속성: 아이디 ---------> 변수( String id )
	      이름                ( String name)
	 동작: ..   ----------> 메서드

   5) 클래스 문법:

	public class  클래스명{
	
	    //구성요소 3가지

	    //1.변수( 인스턴스 변수, 멤버 변수)
	    //2.메서드 ( 멤버 메서드 )
	    //3.생성자 ( 멤버에 속하지 않음 )

	}

    클래스:  현실세계의 객체 개념에서 옴.
           사용자 지정 식별자이지만 권장은 반드시 첫글자 대문자, 명사형 

    변수:    현실세계의 객체의 속성에서 옴.
           사용자 지정 식별자이지만 권장은 소문자, 명사형 

    메서드:  현실세계의 객체 동작에서 옴.
           사용자 지정 식별자이지만 권장은 소문자, 동사형 

    생성자: 클래스 사용시 도움을 줌.
          역할은 변수 초기화임.
	   사용자 지정 식별자이지만 반드시 클래스명으로 지정해야 된다. (****)

   예> 애완동물 관리 프로그램 개발 의뢰

      분석단계: 고양이(객체)
              속성: 이름, 나이, 성별
	      동작: 뛰기, 자기, 먹기

      설계단계:  Cat 클래스
              변수: 이름, 나이, 성별
	      메서드:뛰기, 자기, 먹기

         public class Cat{

                //변수
		String name;
		int age;
		String gender;

                //메서드
		//생성자

	 }
    주의할점은 위 Cat 클래스에는 main 메서드가 없다. (*******************)
    main 메서드가 없는 이유는 재사용하기 위함이다. 하지만 실행하지 못한다.
    따라서 Cat 클래스 이외의 main 메서드를 가진 클래스를 추가해야 된다.


  6) 재사용 클래스 특징

    - main 메서드가 없음.
      독자적으로 실행이 불가.
    - main 메서드를 가진 클래스 도움을 받아서 재사용 클래스를 사용한다.
      방법은 객체 생성한다.
     
     TestCat                     Cat
     main(){}                    String name;
                                 int age;
				 String gender

  7) 객체 생성 (***********)
   
   용도: main 메서드가 없기 때문에 독자적으로 실행이 안됨. 즉 메모리에 못 올라감.
        따라서 main 메서드를 가진 클래스 도움을 받아서 메모리에 올라가게 된다.

   문법: 

      클래스명  변수명 = new  클래스명( [값,값2,..] );  // 값은 옵션
  
    main(){
     Cat c = new Cat();

    }

     c: 변수, 로컬변수, 데이터타입은 Cat 타입, 참조형, Cat 클래스 타입.
        stack 메모리에 저장.


  8) 인스턴스 멤버(변수, 메서드) 접근하는 방법  

     - 반드시 객체 생성이 우선되어야 한다.

       Cat c = new Cat();

     - 문법:
      
        c.멤버

	예>
	  c.name="나비";
	  c.age=2;
	  c.gender="암컷";

  9) 용어 정리
    Cat 객체(object): 분석단계
             Cat객체
	       속성:이름,나이,성별
	       동작:...

    Cat 클래스(class): 설계단계
     
               Cat 클래스
	       변수:이름,나이,성별
	       메서드:...

	       예> public class Cat{
		      String name;
		      int age;
		      String gender;
	          }
           클래스 역할: 실제 고양이(인스턴스)를 관리하기 위한 틀(설계도) 역할이다.

    Cat 인스턴스(instance): 실행(구현)단계

               - Cat c = new Cat(); // 객체생성, 인스턴스화, 메모리 로딩, 메모리에 생성
               
	       - heap 메모리에 Cat 클래스의 구성요소인 멤버(인스턴스변수와 메서드)가 생성된다.
	         이렇게 생성된 멤버접근은 c.멤버 문법을 따른다.

                 //초기화
		 c.name="나비";
		 c.age=2;
		 c.gender="암컷";

               - 인스턴스 변수는 new 할때마다 매번 생성된다.
	         이유는 각각의 고양이 정보를 저장해야 되기 때문이다.


2.생성자 ( Constructor )

 1) 용도:
         인스턴스 변수를 초기화하는 역할이다.
	 (직접 인스턴스 변수를 접근해서 초기화하는 방법도 있음.)
 
 2) 문법:

       public 클래스명( [변수,변수1,..] ){  // 변수를 파라미터(parameter) 라고 부른다.( 파라미터 변수),로컬변수,stack저장
	   실행문장;
       }

       호출방법:  new 클래스명( [값, 값1,..]); // 값은 인자(arguments) 라고 부른다. ( 인자값 )
               호출시 반드시 3개가 일치해야 된다. ( 인자의 갯수 일치, 타입 일치, 순서일치 )

     예> public Cat(){}   <===========   호출방법:   new Cat();
        public Cat( String s){} <===========   호출방법:   new Cat("나비");
	public Cat( int n){}    <===========   호출방법:   new Cat(2);
	public Cat( String s, int n){} <===========   호출방법:   new Cat("나비", 2);
	     
        
	public Cat( String s){} <=== new Cat(); //에러, 갯수 불일치
        public Cat( String s){} <=== new Cat(10); //에러, 타입 불일치
        public Cat( String s, int n){} <=== new Cat(10,"나비"); //에러, 순서 불일치

 3) 특징:
    - 반드시 클래스명으로 지정해야 된다.
    - 반드시 호출해야 생성자가 실행이 된다. ( 객체생성시 생성자가 호출됨 )
    - 동일한 이름으로 생성자를 여러개 작성할 수 있다. ( 오버로딩 생성자: overloading )
      단, 반드시 파라미텃의 개수가 다르거나 타입이 다르거나 순서가 달라야 된다.

4) 기본 생성자 ( default constructor )

   -개념:
      모든 클래스에는 자동으로 파라미터 없는 생성자를 만들어 제공한다.
      이러한 생성자를 기본 생성자( default constructor )라고 부른다.

     예> public 클래스명(){}

    따라서 객체생성시 사용하는 다음 코드에서 에러가 발생되지 않는다.

       클래스명 변수 = new 클래스명(); //객체생성

  -특징:  만약에 개발자가 명시적으로 생성자를 만들면 
        기본 생성자는 제공되지 않는다. 
	이유는 개발자가 만든 생성자를 이용해서 new 하라는 의미이다.

        필요하다면 명시적으로 기본생성자를 작성할 수 있다. ( 오버로딩 생성자 )

/////////////////////////////////////////////////////
5일차 리뷰

1. OOP ( Object Oriented Programming, 객체지향 프로그래밍 방법론 )

               OOP 프로그래밍
  현실세계 ---------------------> 가상세계(자바)
  객체(사물) ======================> 클래스
  -속성     ======================> 변수(인스턴스 변수, 멤버변수)
  -동작     ======================> 메서드( (인스턴스)메서드, 멤버메서드)

  객체간의 관계 존재 
  예> 부모와 자식관계  ===============> is a 관계 (상속관계(Inheritance))
     상사와 부하직원관계
     강사(교사)와 학생관계  
     학생과 노트북 관계  ============>  has a ( use a) 관계

2. 클래스 

 1) 문법
  
     public class  클래스명{
    
        //구성요소 3가지
	// 변수(인스턴스 변수, 멤버변수)
	// 메서드( (인스턴스)메서드, 멤버메서드)
	// 생성자

     }

   클래스명: 권장방법은 첫글자 대문자, 명사형
   변수(인스턴스 변수, 멤버변수): 권장방법은 모두 소문자, 명사형
                           용도는 데이터 저장.
                          생성시점은 new 할 때(객체생성)
			  heap 메모리에 생성

   메서드( (인스턴스)메서드, 멤버메서드): 권장방법은 모두 소문자, 동사형
                                용도는 변수값을 수정,검증,조회등 다양한 기능처리.
                                생성시점은 new 할 때(객체생성)
				method area 에 만들어지고 heap 참조에서 사용됨. 이유는 메서드는 동일한 코드이기 때문이다.

   생성자: 반드시 클래스명으로 지정.
         용도는 변수 초기화.
	 생성자의 파라미터(갯수,타입,순서)가 다른 여러 생성자를 지정할 수 있다. 이것을 오버로딩(overloading)이라고 부른다.
         명시적으로 생성자를 지정하지 않으면 기본 생성자(default constructor)가 자동으로 제공이 된다.
	 역으로 명시적으로 생성자를 지정하면 기본생성자는 제공되지 않는다.

  2) 객체 생성 ( new )

    - 개념: 작성된 클래스를 사용하기 위해서 반드시 메모리에 올리는 작업 의미
    - 문법:

          클래스명  변수명 = new 클래스명( [값,값1,..]);

        변수명: 데이터타입은 지정된 클래스가 된다.
	      8개의 기본형데이터에 포함되지 않기 때문에 참조형 데이터임.
	      따라서 변수에 저장되는 값은 주소값을 저장하게 된다.


        클래스명( [값,값1,..]): 생성자를 호출하는 코드이다.
	                    반드시 인자(갯수,타입,순서)가 같아야 된다.
	

        heap 메모리에 생성된 멤버(인스턴스변수,메서드) 접근방법: 변수명.멤버 문법을 따른다.

///////////////////////////////////////////////////////////////////////////////////////////////
6일차 

1. 은닉화 ( encapsulation, 캡슐화 )
 
  -개념: 외부에서 직접 접근하지 못하도록 구성요소를 숨기는 작업.
  -방법: 접근 지정자 ( access modifier ) 이용

      public: 접근 제한이 없다.
      protected
             (default)
      private: 외부 클래스에서 접근 불가. ( 은닉화 )
     
 - 사용 가능한 곳

     클래스: 4가지 모두 사용 가능. 일반적으로 public 로 지정함.
     변수(인스턴스, static): 로컬변수는 사용불가.
                         4가지 모두 사용 가능. 일반적으로 private 로 지정함.(이유는 은닉화 때문)
                         private로 지정하면 직접 접근은 불가능하고 생성자 및 메서드를 통해서 변수를 간접 접근한다.
     메서드: 4가지 모두 사용 가능. 일반적으로 public 로 지정함.
     생성자: 4가지 모두 사용 가능. 일반적으로 public 로 지정함.

2. this 키워드

 1) 개념: 
    
    객체생성후 heap 메모리에 생성된 자신의 인스턴스를 가리키는 방법이다.
    외부에서는 객체생성시 사용했던 변수 (예> Cat c = new Cat())인 c를 이용한다.

 2) 문법:
         this.인스턴스변수;
	 this.메서드
 3) 특징:
     - 일반적으로 생략이 사용된다.
     - 반드시 사용해야 되는 2가지 경우가 있다.

      가. 인스턴스 변수명과 파라미터명(로컬변수)이 동일한 경우

        예>
	      String name;
	      int age;

             public Cat( String n,   int n2 ){
                 name = n;
                 age = n2;
	     }
            // 다음과 같이 인스턴스변수명과 로컬변수명이 동일한 경우
            public Cat( String name,   int age ){
                 this.name = name;
                 this.age = age;
	     }   
        
       나. 특정 생성자에서 다른 생성자를 호출할 때
          (외부)일반적으로 생성자를 호출하는 방법? new 클래스명([값,...])
	  내부에서 생성자를 호출하는 방법?  this([값,...])

          예>

	        public Dog(String name, int age) {
		   this(name,age, null);
		  // this.name = name;
		  // this.age = age;
		}
		public Dog(String name, int age, String gender) {
			this.name = name;
			this.age = age;
			this.gender = gender;
		}

          용도: 개별적인 생성자에서 인스턴스 변수를 초기화하지 않고 (중복코드 존재)
	      특정 생성자 하나에서 인스턴스 변수를 초기화할 목적이다.

	  주의할점: 반드시 생성자에서 호출해야 된다.
	          호출시 첫라인에서 호출해야 된다.


3. 메서드 (method)


  1) 문법:

       public  리턴타입  메서드명( [값, 값1,.] ){
		
	    문장1;
	    문장2;
	    ..
	    [return 값;]
       }

    * 생성자 문법
      public 클래스명( [값, 값1,.] ){
           문장1;
	   ..
      }
    
    * 생성자와의 차이점
      - 리턴타입이 있음.
      - 메서드명이 사용자 지정 식별자이기 때문에 임의로 지정가능. ( 권장은 모두 소문자, 동사형 )
      - 블럭({}) 마지막에 return 값; 사용할 수 있다.

    * 생성자와 공통점
      - 반드시 호출해야 된다.
        생성자 호출방법: new 클래스명(값,..);
	메서드 호출방법: 우선적으로 객체생성하고 ( 클래스명 변수 = new 클래스명(값,..); )
	            인스턴스 변수 접근방법과 동일하게 변수명.메서드 형식으로 호출한다.
      - 생성자와 메서드 호출된 후에는 반드시 호출한 곳으로 돌아간다.

  2) 용도
    - 인스턴스 변수를 관리하는 역할 ( 수정, 조회, 검증, ... )
     실습에서는 인스턴스 변수를 수정하고 조회하는 메서드를 작성할 것이다.

  3) 메서드 종류1- 파라미터 및 리턴 존재 여부
   
      public  리턴타입  메서드명( [값, 값1,.] ){
		
	    문장1;
	    문장2;
	    ..
	    [return 값;] //리턴값, 반드시 리턴값에 해당되는 리턴타입을 지정해야 된다.
	                  만약 리턴값이 없으면 리턴타입은 void 로 지정한다.
       }
    
     * 오버로딩 메서드 ( overloading )
      -개념: 하나의 클래스에 동일한 이름의 메서드가 여러개 지정이 가능한 경우.
            단 인자의 갯수,타입,순서는 반드시 달라야 된다.
	    리턴타입과는 무관한다.
      -목적: 재사용성.


    가. 파라미터 없고 리턴값도 없는 형식

        문법:  
            public void 메서드명(){
                  문장1;
		  문장2;
	    }

	호출방법:
	        클래스명 변수 = new 클래스명();
		변수.메서드명();  // 반드시 인자갯수,타입,순서가 일치해야 된다.
 
   
   나. 파라미터 있고 리턴값이 없는 형식
 
       문법:  
            public void 메서드명(변수, 변수2,...){
                  문장1;
		  문장2;
	    }

       호출방법:
	        클래스명 변수 = new 클래스명();
		변수.메서드명(값, 값2,...);  // 반드시 인자갯수,타입,순서가 일치해야 된다.
 

  다. 파라미터 없고 리턴값이 있는 형식
    
      
        문법:  
            public 리턴타입 메서드명(){
                  문장1;
		  문장2;

		  return 값;  // 리턴되는 값은 반드시 하나임.
		                만약 리턴되는 값이 여러개 라면? 해결은 하나로 만들면 됨. ( 하나의 문자열 또는 배열 또는 컬렉션 )
	    }

	    예> public int method3(){
                   ..
		   return 100;
	       }
	       public String  method3(){
                   ..
		   return "홍길동";
	       }
	        public String  method3(){
                   ..
		   return 10+"홍길동";
	       }

	        public int[]  method2(){
                   ..
		   return new int[]{10,20,30};
	       }
             
	       public int[]  method2(){
                   ..
		    int[] num =  new int[]{10,20,30};
		   return num;
	       }
	      

	호출방법:
	        클래스명 변수X = new 클래스명();
		변수1 = 변수X.메서드명();  // 변수1에 호출된 메서드가 리턴된 값이 저장된다.


    라. 파라미터 있고 리턴값도 있는 형식
  
        문법:  
            public 리턴타입 메서드명(변수1, 변수2,...){
                  문장1;
		  문장2;

		  return 값;  
		               
	    }

	호출방법:
	        클래스명 변수X = new 클래스명();
		변수1 = 변수X.메서드명(값1, 값2, ...);


   3) 메서드 종류2 - 기능

     가. 데이터를 얻는 기능
        - getter 메서드 라고 부른다.
	- getter 메서드의 이름은 관례적으로 get변수명( 카멜표기법 ) 으로 지정한다.
 
            예> name을 얻는 경우:  getName(){}
	       age을 얻는 경우:  getAge(){}

	    * 케밥 표기법 ( get-name )
	      스네이크 표기법 ( get_name )


     나. 데이터를 설정하는 기능
       - setter 메서드라고 부른다.
       - setter 메서드의 이름은 관례적으로 set변수명( 카멜표기법 ) 으로 지정한다.
 
        예> name을 설정 하는 경우:  setName(String name){}
	   age을 설정 하는 경우:  setAge(int age){}


4. 메서드 호출시 파라미터에 전달하는 값의 종류 2가지(기본형, 참조형)의 전달 방식. (***************)

    가. 기본형 값 전달 ( call by value )
       - 동일한 기본형 값이 호출된 메서드에 생성된다.
         따라서 호출된 메서드에서 값을 변경해도 원래 값이 변경이 안됨.

    나. 참조형 값 전달 ( call by value reference )
       - 동일한 참조형 값이 생성되지 않고 
         단지 생성된 하나의 값을 참조하는 변수가 하나 더 생성된다.
	 따라서 호출된 메서드에서 값을 변경하면 원래 값이 변경이 된다.

       - 예> 클래스, 배열

 ////////////////////////////////////////////////////////////////
 6 일차 리뷰

 1. 클래스
   - 자바 프로그램의 최소 단위.
   - 구성요소
      
      변수(인스턴스변수, 멤버변수): 객체의 속성 저장하는 용도
      생성자: 인스턴스변수에 값을 초기화하는 용도. ( 변수를 직접 접근하거나 메서드 통해서도 초기화는 가능)
           가능한 이유가 객체생성할 때 의무적으로 생성자가 호출됨
	   예> Cat c = new Cat("나비",2);
	      c.name="나비";    // 권장 안함
	      c.setName("나비2");// 값을 수정

      메서드(인스턴스메서드, 멤버메서드): 기능처리 담당. (예> 기본적으로 변수값을 수정(setter)하거나 조회(getter)하는 기능 )

    ===> 나중에는 생성자와 getter/setter 메서드를 자동으로 포함하는 외부 jar(lombok 라이브러리)를 사용할 것이다.

   - 문법:

         public class 클래스명{

	     (인스턴스)변수
	     생성자
	     (인스턴스)메서드

	 }

      사용방법: 작성된 클래스(사용자가 만든 클래스, API )는 반드시 객체생성해야 된다.
             결국 모든 클래스는 반드시 객체생성해야 된다.

             클래스명  변수 = new 클래스명([값,값2,..]);

             변수.멤버  형식으로 인스턴스 변수 및 메서드를 참조할 수 있다.

             new 이용하면 클래스의 구성요소가 heap 메모리에 생성이 된다.
	     heap 메모리에 생성된 상태를 인스턴스(instance)라고 부른다.

          
 2. 생성자 ( constructor )

    - 용도: 인스턴스 변수 초기화
    - 문법:

          public 클래스명([변수,..]){}
            
    - 특징:
         반드시 클래스명으로 지정해야 된다.
	 반드시 호출해야 실행이 된다.

	 1) 다른 클래스에서 호출
             - new 이용
	     예> new 클래스명([값,값2,..])

	 2) 같은 클래스에서 호출
	     - this 이용, 반드시 생성자 첫라인에서 호출해야 된다.
	     예> this([값,값2,..])

	 개발자가 명시적으로 생성자를 지정하지 않으면 자동으로 생성자가 제공된다. ( 기본 생성자 라고 부른다)
	  ==> public 클래스명(){}
          단 개발자가 명시적으로 생성자를 지정하면 기본 생성자는 제공이 안된다.
	  필요시 여러 생성자를 명시적으로 지정할 수 있다. ( 오버로딩(overloading) 생성자라고 부른다. )
          오버로딩(overloading) 생성자 규칙: 인자갯수,타입,순서가 달라야 된다.

3. 메서드

   - 용도: 인스턴스변수 관리( 조회,수정,검증....) <== 기능처리
   - 문법:
    
         public 리턴타입 메서드명([변수,변수1,..]){  // 변수를 파라미터(parameter) 라고 부름.
                 문장;
              
	      [return 값;]    // 값을 리턴값으로 부름. 리턴값은 없거나 반드시 한개만 지정이 가능함.
	 }

   - 특징:
         반드시 호출해야 실행된다.

	1) 다른 클래스에서 호출
           반드시 객체생성후에 호출할 수 있다.
            클래스명  변수 = new 클래스명([값,값2,..]);
            변수.메서드([값,값2,..]);


	2) 같은 클래스에서 호출
	   this.메서드([값,값2,..]); 인데 일반적으로 this. 생략한다.

	   예>  
	      public void a(){
	        //this.b();
		b();
	      }
              public void b(){
	      }

   - 메서드 종류1 - 파라미터 및 리턴값 존재 여부
    
      가. 파라미터 없고 리턴값 없는 형식 ( 거의 사용 안함 )
         
	 문법:
	      public void method1(){}

	      클래스 변수 = new 클래스명();
	      변수.method1();

      나. 파라미터 있고 리턴값 없는 형식 ( setter 메서드 )

          문법:
	      public void method1(int n, String n2){}

	      클래스 변수 = new 클래스명();
	      변수.method1(10, "나비");   

      다. 파라미터 없고 리턴값 있는 형식 ( getter 메서드 )
          문법:
	      public int method1(){
	      
	         return 100;
	      }

	      클래스 변수1 = new 클래스명();
	      변수 = 변수1.method1(); 

      라. 파라미터 있고 리턴값 있는 형식 

          문법:
	      public int method1(int n, int n2){
	      
	         return n+n2;
	      }

	      클래스 변수1 = new 클래스명();
	      변수 = 변수1.method1(10,20); 

   - 메서드 종류2 - 기능
      가. setter 메서드
      나. getter 메서드

   - 메서드 종류3 - static 사용여부
      가. 인스턴스 메서드
      나. static 메서드

   - 메서드 종류4 - 메서드 기능이 구체화 여부
      가. 메서드(인스턴스,static)
         ==> {}가 있음.

      나. 추상메서드(abstract method)
         ==> {}가 없음.

    - 오버로딩 메서드( overloading )
       오버로딩(overloading) 메서드 규칙: 인자갯수,타입,순서가 달라야 된다.
                                    메서드의 리턴타입과 무관.

4. return 키워드

  용도1: 기본적으로 메서드가 호출후에 실행결과를 호출한 곳으로 돌아갈때(리턴될때)
       실행결과값(리턴값)을 전달하는 역할이다.

  용도2: 메서드 실행을 중지할 때.


      예>  public void method(){
               문장1;
	       if(조건식)return;
	       문장2;
	       문장3;
          }

         클래스 변수1 = new 클래스명();
	 변수1.method();


5. call by value 와 call by value reference

   - 기본적으로 자바는 메서드 호출시 전달할 수 있는 값은 값 자체이다.
     기본값: 정수값,실수값,논리값,.. ( 결론적으로 전달받은 메서드에서 동일한 기본값이 하나 더 생성된다. 실제값은 2개가 됨. )
     참조값: 주소값              ( 결론적으로 전달받은 메서드에서 동일한 주소값이 하나 더 생성된다. 
                               실제값은 하나이고 2개의 참조변수가 생김.)
 
  1) call by value
     - 기본 데이터 값을 파라미터로 전달되는 메커니즘.

  2) call by value reference
     - 참조 데이터 값을 파라미터로 전달되는 메커니즘.

//////////////////////////////////////////////////////////////////////////
7일차

1. static 키워드 (정적)

  1) 개념 및 특징: 프로그램 실행과 관련된 키워드. ( 객체생성과 무관, 객체생성전에 미리 결정된다. 정적인 특징을 가짐. )
                프로그램 실행은 단 한번만 가능하다.
	        static으로 지정된 변수, 메서드, 클래스는 프로그램 실행할 때 생성이 된다. (****************)
	        method area 메모리에 생성이 된다.

	  //////////////////////////////////////////////////////////////////////
          객체생성과 관련된 키워드: new, this, 인스턴스,인스턴스변수, (인스턴스)메서드, heap메모리
	                     객체생성은 여러번 가능하다.
	  메서드호출과 관련된 키워드: 로컬변수, statck 메모리, 오버로딩 메서드, 4가지형식, getter/setter, 추상메서드
	                     메서드 호출은 여러번 가능하다.
	  //////////////////////////////////////////////////////////////////////

  2) 변수 종류

    가. 로컬변수
       - 메서드안에서 선언.
       - 생성~소멸: 메서드호출  ~  메서드종료.
       - 저장메모리: stack 
       - 특징: 메서드 호출할 때마다 매번 생성된다.
       - 초기화: 명시적으로 초기화해된다. ( 컴파일 에러 )

    나. 인스턴스변수
       - 메서드밖에서 선언.
       - 생성~소멸: 객체생성(new)  ~  객체소멸.
         
	          객체소멸? heap 메모리에 생성된 인스턴스를 참조하는 변수가 없을 때.
		          GC(Garbage Collector) 가 인스턴스를 제거함
       - 저장메모리: heap
       - 특징: new (객체생성)할 때마다 매번 생성된다.
       - 초기화: 자동으로 초기화 된다. ( 정수:0, 실수:0.0, 논리:false, 참조: null)
       - 사용방법:  반드시 객체생성후에 사용한다.
        
	         클래스 변수1 =  new 클래스();
                 변수1.인스턴스변수;


    다. static 변수( 클래스 변수)
       - 메서드밖에서 선언. static 키워드 지정.
       - 생성~소멸: 프로그램 실행  ~  프로그램 종료. scope가 가장 길다.
       - 저장메모리: method area
       - 특징: 프로그램 실행 할때 한번만 생성된다. ( new 무관 )
             한번만 만들어지고 scope 가 가장 긴 특징이 있기 때문에 
	     주로 데이터를 누적용으로 사용된다.
	     여러 인스턴스가 데이터를 공유할 수 있다.
       - 용도: 데이터 누적용 및 데이터 공유
       - 초기화: 자동으로 초기화 된다. ( 정수:0, 실수:0.0, 논리:false, 참조: null)              
       - 사용방법:  객체생성(new)와 무관하다.

                  클래스명.static변수;

  3) (인스턴스) 메서드 와 static 메서드

     가. (인스턴스) 메서드
       - 문법:
           public void method1(){}

       - 생성~소멸: 객체생성(new)  ~  객체소멸.

       - 용도:  인스턴스 변수를 관리 목적 ( 수정, 조회, 검증...)

       - 사용방법:  반드시 객체생성후에 사용한다.
        
	         클래스 변수1 =  new 클래스();
                 변수1.메서드();

          예> Scanner scan = new Scanner(System.in);
	     int num = scan.nextInt();

  
     나. static 메서드
      - 문법:
           public static void method1(){}

      - 생성~소멸: 프로그램 실행  ~  프로그램 종료.
      - 용도: 객체생성없이 기능 처리 목적.

       - 사용방법: 
                 클래스.메서드();

           예>  int num = Integer.parseInt("10")

       - 주의할점: new(객체생성)과 무관하기 때문에 
                new, this, 인스턴스,인스턴스변수, (인스턴스)메서드, heap메모리 

        * static 메서드 vs instance 메서드 
          static 메서드: 개별적인 instance(Cat, Dog)와 무관한 기능처리.
          instance 메서드: 개별적인 instance에 국한된 기능처리
	                  예> Cat의 name속성을 수정하는 setName()
 

   4) 일반 클래스와 static 클래스
     
      - static 클래스는 반드시 중첩 클래스에서만 사용이 가능하다.

       중첩클래스: 클래스안에 또 다른 클래스가 선언된 경우

         예>
	      public  class 클래스명{ // outer클래스
		

		 public class 클래스명{ // 중첩클래스, inner 클래스

		 }

	         public static class 클래스명{ // 중첩클래스, inner 클래스

		 }
	      }

    5) static 블럭 (***************)

     문법:
          static{
	     실행 문장1;
             실행 문장2;
	  }
    
      이전 방식에서는 실행문을 실행시키기 위해서 생성자 블럭({}) 또는 메서드 블럭({})을 사용했음.
      생성자 블럭을 사용하기 위해서는 반드시 new 해야되고
      메서드 블럭을 사용하기 위해서는 객체생성후 변수명.메서드() 형식을 사용해야 된다.
      그런데 static 블럭은 자동으로 프로그램 실행할 때 실행이 된다.
      따라서 매우 편리하게 특정 실행문을 실행시킬 수 있다.

2. package와 import 문

   1) package

     용도: 클래스 파일 관리 목적 ( 윈도우의 폴더와 비슷 )
     문법:
           package 패키지명;  // 단일 패키지

	   또는

	   package 패키지명.패키지명2;  // 서브 패키지
           package 패키지명.패키지명2.패키지명3; // 서브 패키지

    ==> 실행하면 폴더처럼 보인다.
    ==> package 사용하지 않는 클래스는 패키지가 없는 것이 아니고 default 패키지를 사용했다고 한다.

      예> com.exam 패키지 생성하고 Test.java 클래스 작성하자
         com.exam2 패키지 생성하고 Test2.java 클래스 작성하자

     특징: 패키지가 다르면 클래스들간에 접근이 불가. ( 해결: import 문)
          식별이 가능하기 위해서 패키지는 유일해야 된다. ( 일반적으로 회사 도메인으로 지정한다. 예> com.ssg )
	  Java API( 자바에서 제공해준 클래스파일들) 도 패키지로 만들어서 제공된다. ( 예> java.lang, java.io,java.util, )
	  사용자가 지정한 패키지명을 java API에서 사용하는 패키지명을 사용하면 안된다.
          pacakge 문은 클래스 당 한번씩만 사용 가능.
	  package 가 다르면 동일한 이름의 클래스 작성이 가능하다

   2) import 문

      용도: 서로 다른 패키지에서 클래스를 접근하는 방법.
          기능은 클래스가 위치한 경로를 알려주는 방법.

      문법:

            import 패키지명.패키지명2.클래스명;
	    import 패키지명.패키지명2.*;     // * 의미가 모든 클래스를 import 한다. 권장안함


            패키지명.패키지명2.클래스명 변수 = new 패키지명.패키지명2.클래스명();
   
      특징:  
            여러번 사용 가능.
	    API 중에서 java.lang 패키지는 자동으로 import 된다.
	    java.lang 이외의 패키지는 반드시 명시적으로 import 해야 된다.


 3. UML ( Unified Modeling Language )

   - 설계단계에서 추출되는 다양한 산출물들을 도식화하는 도구.

     구글: 클래스 다이어그램
////////////////////////////////////////////////////////////////////////////

* 클래스 관계

 - use a 관계 : 학생 uas a 컴퓨터. 
               연관관계(association)
	       UML: 학생 ---------------> 컴퓨터
                public class 학생{
		   컴퓨터 c; // 인스턴스 변수
		}
		public class 컴퓨터{

		}

 - has a 관계 : 자동차 has a 바퀴.  Cafe has a Coffee.
  (집합관계. whole-part 관계)              
               
	       aggregation 관계: 자동차 has a 라디오
	                       자동차와 엔진의 lifecycle 다르다.
	       UML: 자동차 비어있는마름모-----------라디오

	       composition 관계: 자동차 has a 엔진.
	                        자동차와 엔진의 lifecycle 같다.
               UML: 자동차 채워진마름모-----------라디오

                public class 자동차{
		   엔진 c; // 인스턴스 변수
		}
		public class 엔진{

		}

 - is a 관계 : 대학생 is a 학생.
 (상속 관계)
//////////////////////////////////////////////////////////////////////
8일차

1. 상속 ( inheritance )

  1) 특징
   
   가. is a 관계가 성립해야 된다.
     
      예> 대학생 is a 학생
         엔지니어 is a 사원, 관리자 is a 사원
 
   나.  Engineer is a Employee 경우에는 UML 표기법은 다음과 같다. ( 삼각형의 실선 )

          Employee ( 부모 클래스, parent 클래스, super 클래스, 개념적으로 큰 타입 )
             |
             |   <-- 삼각형 실선
	     | 
	  Engineer ( 자식 클래스, child 클래스, sub 클래스, 개념적으로 작은 타입 )

   다. is a 자바 코드로 표현은 자식클래스에서 extends 부모클래스  형식을 따른다.

        public class Employee {
	     //인스턴스변수
	     //메서드
	     //생성자
	}
        public class Engineer extends Employee {} // Engineer 와 Employee 는 상속관계라고 할 수 있다.

   라. 자바는 단일 상속(single   inheritance)만 지원된다.  
      ==> extends 뒤에 명시한 부모클래스는 단 하나만 가능.

   마. 상속의 가장 큰 장점은 부모의 멤버(인스턴스변수, 메서드)를 자식이 그냥 사용할 수 있다. ( 재사용성 )
      이것을 상속해서 사용한다고 말한다.

      상속이 안되는 2가지 
      - 부모생성자
      - private으로 지정된 멤버(인스턴스변수, 메서드)

   바. 명시적으로 extends 부모클래스 코드가 없는 클래스는 자동으로  extends Object가 설정이 된다.
      java.lang.Object 클래스로서 모든 클래스의 부모라고 할 수 있고 최상위 클래스라고 부른다.
      따라서 자바 클래스는 계층적인 구조를 가지게 된다.
      그리고 Object의 멤버를 모든 클래스가 사용할 수 있다.

       Object ( 최상위 클래스 )
          |
          |
       Employee
          |
          |
       Engineer    Manager


   사. 명시적으로 자식에서 부모를 호출할 수 있다.
       ( super 키워드 이용)
       * 부모를 호출하는 형태

       a. 부모의 멤버 호출
          super.멤버
	 ==> 부모의 멤버이름과 자식의 멤버이름이 동일한 경우.

       b. 부모의 생성자 호출
         문법: super([값,..])
	 특징: 항상 자식보다 부모를 먼저 생성해야 되기 때문에
	     자식 생성자 첫 라인에 자동으로 super() 삽입이 된다.
	     결국 모든 클래스의 부모인 Object 가 가장 먼저 생성된다.
	     필요시 명시적으로 super([값,..]) 지정할 수 있다.
             명시적으로 호출하는 경우는 부모에서 선언한 멤버를
	     부모에서 초기화할 목적이다. 반드시 첫라인에서 호출해야됨.
	     예> super(name, salary); 
	     
    아. 항상 자신보다 부모를 먼저 생성한다.
       ( 자식의 생성자 첫라인에서 자동으로 super()가 삽입되어 부모의 기본생성자가 자동으로 호출되기 때문 )

   2) 상속 구현 방법
    
     가. 상속이전 코드는 클래스간에 중복되는 코드가 많다.

       Engineer            Manager
       String name;        String name;   
       int salary;         int salary;
       String skill;       String depart;
    

    나. 상속적용
       a. Engineer와 Manager를 아우르는 큰 개념의 클래스를 작성한다.

               Employee

       b. 큰 개념의 클래스인 Employee 안에 Engineer와 Manager 의 공통적인 멤버를 정의한다.

       c. 상속을 적용 

          
			Employee ( 부모 클래스, 큰 개념, 큰 타입 )
			  |
			  |
			  |
                   Manager    Engineer (자식 클래스, 작은 개념, 작은 타입 )


      다. 오버라이딩(overriding) 메서드  
        개념: 상속이 전제가 된 상황에서 부모의 메서드를 자식이 필요에 의해서 수정할 수 있으며
	     이렇게 수정된 메서드를 의미한다. 재정의 메서드라고도 부른다.
	     반드시 @Override ( 어노테이션: annotation ) 지정한다
	     가장 큰 단점은 강제성이 없다

	     단, 다음과 같은 규칙이 있다.
	       - 부모의 리턴타입과 동일.
               - 부모의 메서드명과 동일.
	       - 부모의 메서드 파라미터와 동일
	       - 부모의 접근지정자는 달라질 수 있음.
	         단, 부모가 지정한 접근지정자와 같거나 덜 제한쪽인 위로 지정할 수 있다. ( 밑으로 지정하면 에러발생 )
		 public
		 protected
		        (default)
	         private

	   부모의 메서드:                   void a( int x){}
                                        
                                        @Override
           자식(오버라이딩)메서드:             void a(int y){}

         목적: 재사용성
       ///////////////////////////////
         * 오버로딩(overloading)메서드/생성자
	 개념: 하나의 클래스안에 동일한 이름의 메서드 및 생성자가 여러개 지정이 가능하다.
	      단, 인자의 개수,타입,순서가 달라야 된다.

	      예>  public void a(){}
	          public void a(int n){}
		  public void a(String n){}
		  public void a(String n,int n2){}
		  public void a(int n, String n2){}

		  public int a(){} // 에러 발생, 리턴타입과 무관

         목적: 재사용성
	 대표적: System.out.println(값);
       //////////////////////////////

2. java.lang.Object 클래스

   특징:
      - 모든 클래스들의 최상위 클래스 ( root 클래스 )
        이유는 클래스 생성할 때 항상 자신보다 먼저 부모를 생성하는 메커니즘 때문이다.

	    Object
               |
            Employee
               | 
	    Manager       


	    Manager m = new Manager(); // 생성되는 순서: Object > Employee > Manager

      - Object 클래스에는 현재 10개의 메서드가 제공됨. ( finalize()는 Deprecated 됨)
       필요시 자식클래스에서  10개의 메서드를 재정의 할 수 있다. ( 오버라이딩 )
        특히 toString() 메서드는 관례적으로 재정의해서 사용한다. (****************)

        Object의 toString() 구현 ?
           
	      ==> public String toString(){
	            return getClass().getName() + '@' + Integer.toHexString(hashCode());
		  }
              ==>  heap 메모리에 생성된 인스턴스 주소값( Ox100 )을 문자열로 변환해서 출력하는 기능.
                   예> Ox100 주소값 ================>  "클래스명@16진수" 

        Object의 toString() 메서드 호출 시점?
	     ==> 참조변수를 System.out.println(참조변수) 하면 자동으로 호출이 된다.
	         필요시 System.out.println(참조변수.toString()) 명시적으로 호출할 수도 있다.
		 따라서 다음 2 코드는 동일한 코드이다.
		 예> String s = "hello";
		    System.out.println(s);  // 자동으로 toString() 호출됨
		    System.out.println(s.toString());

	API의 toString()는 거의 대부분 미리 재정의해서 사용한다. 
	( 즉 클래스@16진수 리턴하지 않고 실제값이 리턴되도록 재정의함 )
        대표적인 API: String, Date, Integer ...
	따라서 사용자가 만든 클래스도 toString() 재정의해서 매우 쉽게 모든 데이터를 출력할 수 있다.
	
	* 재사용 클래스의 가장 기본되는 템플릿 구조는 다음과 같다.

	  public class Cat{
 
              // 인스턴스 변수
	      // 생성자 ( 기본생성자 및 파라미터 지정한 생성자)
	      // 메서드 ( getter/setter)
	      // toString 재정의 <== 전체 데이터를 반환하는 getCat() 메서드가 필요없다.
	  }
     

   

  ////////////////////////////////
   * deprecated
    - 과거에는 사용되었던 코드가 버전업 되면서 사용을 권장하지 않는 코드를 의미.
      만약 사용하면 에러는 아니지만 취소선으로 자동으로 설정됨.
      따라서 사용하지 말아야 된다.
  ///////////////////////////////

 ///////////////////////////////////////////////////////////////
 8 일차 리뷰

 1. 상속 ( inheritance )

   1) 개념: 클래스들간의 관계중 ( use a, has a , is a ) is a  관계가 성립됨.
           결국 is a 는 같은 종류임을 의미함.
	   예>  대학생 is a  학생
	       중학생 is a  학생
	       고양이 is a 애완동물
               강아지 is a 애완동물 
   2) 상속구현

           학생   ( 부모클래스,parent, super 클래스 )
         
       대학생   중학생 ( 자식클래스, child, sub 클래스 )

         - UML 표기법으로는 삼각형 실선
	 - 자바코드로는 extends 부모클래스

    3) 특징
       - 부모의 멤버(인스턴스변수, 메서드)를 자식이 그냥 사용 가능 ( 재사용성이 높아짐. 따라서 코드도 간결해짐 )
       - 상속이 안되는 2가지 ( 생성자, private로 지정된 멤버 )
       - 항상 자신보다 부모를 먼저 생성한다. ( 자식클래스 생성자 첫 라인에서 부모생성자를 자동으로 호출한다. super() )
       - 명시적으로 부모 멤버 및 생성자를 호출할 수 있다.
          부모 멤버: super.멤버 
	  부모 생성자: super([값,..]);
       - overriding 메서드 지원 ( 부모의 메서드를 자식이 재정의 하는 것을 의미 )
        
	 규칙: 부모의 리턴타입과 동일.
	      부모의 메서드명과 동일.
	      부모의 메서드의 파라미터와 동일.
	      부모의 접근지정자와 같거나 덜 엄격한 지정자를 사용.
	      부모에서 지정된 throws 예외클래스는 같거나 자식 클래스를 사용.


	      부모 메서드:          public void method([변수,..]) throws RuntimeException{}
 
                                 @Override
              자식(오버라이딩) 메서드:  public void method([변수,..]) throws ArithmeticException{}
 
	   * 예외클래스 계층구조

	        Object
		   |
		Throwable
		   |
		 Exception
		  |
		 RuntimeException
		  |
		  ArithmeticException
                  ArrayOutofBoundsException
		  NullPointerException

         overriding 불가: private 
                         static 
			 final 

	 * final (마지막)
	 변수: 상수로 되기 때문에 값 변경 불가.
	 메서드: overriding 불가
	 클래스: 상속 불가  ( 예> java.lang.Math )
/////////////////////////////////////////////
9일차

1. 다형성 (Polymorphism)

   1) 개념:  하나의 참조변수가 서로 다른 데이터타입의 인스턴스를 가리키는 능력.
            반드시 상속관계(is a, 같은종류)가 전제되어야 한다

         예>  
	     // 다형성 적용 안됨. 일반적인 객체생성 방법
	     Employee e = new Employee();
	     Manager m = new Manger();
	     Engineer eng = new Engineer();


	     // 다형성 적용
            Employee e = new Employee();
	             e = new Manger();
	             e = new Engineer();

   2) 문법:
           큰타입 변수 = 작은타입;
           작은타입 변수 = 큰타입; //에러발생,해결: (형변환)

	   ( 기본형에서도 비슷하게 적용됨.
	        byte b = 10;
		int b2 = b; )


  3) 동적 타이핑( dynamic typing )
    
     - 개념: 컴파일시점에 자바가 알고 있는 메서드와
            실행시점에 자바가 알고 있는 메서드가 동적으로 변경된다는 개념이다.

	     Employee e = new Manager("이순신", 4000, "개발");
             System.out.println(e); // e.toString() 호출  
	     
	   컴파일 시점의 toString()는 Employee의 toString()으로 알고 있고
	   실행 시점에는 실제 new한 Manager의 toString()으로 실행이 된다

    - 특징: 변수에는 동적 타이핑 개념이 없다.
           메서드에만 존재하는 개념이다.

   4) 자식에서만 추가된 변수 및 메서드는 반드시 형변환해서 사용해야 된다.
	Employee e = new Manager("이순신", 4000, "개발");
	 //e.depart;
	 //e.getDepart(); // 컴파일시 Employee에서 xxx() 찾는다. 해결: 형변환
	// 다음과 같이 형변환해서 자식에서 추가된 메서드 및 변수를 호출할 수 있다.
	Manager m = (Manager)e;
	m.getDepart();
	System.out.println(m.depart);

    5) 다형성 활용

      가. 배열
      Employee [] employee = { new Manager("이순신1", 4000, "개발"),
			       new Engineer("유관순1", 2500, "자바"),
			     new Manager("이순신2", 4000, "개발"),
			     new Manager("이순신3", 4000, "개발"),
			     new Engineer("유관순2", 2500, "자바")
		};
 
       배열 확장 가능하다.
       Object [] obj = { new Manager("이순신1", 4000, "개발"),
			 new Engineer("유관순1", 2500, "자바"),
			 "hello",
			 100,
			 3.14,
			 true,
			 ...
			 };


      나. 메서드 파라미터 
       
         // 다형성이 적용된 메서드
	public static void b(Object obj) {
		System.out.println(obj);		
	}

	b(100);
	b("hello");
	b(3.14);

	==> 오버로딩(overloading)메서드가 불필요하다.
	==> 대표적인 메서드
	    System.out.printf("", "홍길동"); 
	    System.out.printf("", 10); 
	    System.out.printf("", 175.58); 

    6) 다형성에서 원하는 타입에 해당하는 인스턴스 찾기

       문법:  변수 instanceof 클래스명  <==실행결과값은 true/false 반환

     
    나중에 추상클래스와 인터페이스 배울때 다형성 개념이 또 나옴.
///////////////////////////////////////////////////////////////////////////////////////////
2. OOP 3대 특징
 
   - 상속(inheritance)
   - 다형성(polymorphism)
   - 은닉화(encapsulation, 캡슐화) 
     ==>  인스턴스변수는 private 지정해서 외부에 직접 접근이 불가능( 데이터를 직접 저장하면 검증이 안되기 때문 )하도록 만들고
          메서드를 public 지정해서 인스턴스변수를 간접적으로 접근( 데이터를  검증이 가능하기 때문 )하도록 만드는 방법.

     ==>  메서드까지도 private 지정해서 외부에서 볼때 복잡하지 않게 설정할 수 있다.

     최종적으로 은닉화는 접근을 하는 쪽에서는 복잡성을 감소시킬 목적으로 사용하지 않는 접근할 대상의 메서드를 private 로 지정하고
                   접근을 당하는 쪽에서는 변수를 private 로 직접해서 직접 접근을 못하게 해서 데이터를 보호할 수 있다.

     목적: 데이터 보호 및 복잡성 감소.

3.  접근 지정자 ( access modifier, 접근 제어자 )

   1) 용도:  클래스들간의 접근(참조)을 제한하는 방법.
   2) 4가지 레벨
                        같은 클래스    같은패키지의 다른클래스    다른패키지 상속관계       다른패키지의 다른클래스
    ------------------------------------------------------------------------------
     public              가능          가능                 가능                가능
     protected           가능          가능                 가능                불가
         (default)       가능          가능                 불가                불가
     private             가능          불가                 불가                불가

   3) 사용 가능한 곳
     - 클래스 : public 
     - 인스턴스 변수: private
     - static 변수: public
     - 메서드: public
     - 생성자: public
     - 로컬변수는 사용 불가


4. 추상 클래스 ( abstract class )

   1)문법

       // 추상 클래스 ( abstract 클래스, 어떤 기능처리를 할지 구체화되지 않은 클래스, 미완성된 불완전 클래스)
       public abstract class  클래스명{

            //구성요소 4가지
            변수
	    메서드 ( concrete 메서드 : {} 가짐.  )
	    생성자
	    추상메서드( abstract 메서드 : abstract(필수) + {} 없음. {} 없기 때문에 실행되는 동작이 미정.  )
	    예> public abstract void a([변수,..]);
       }

       ==> 추상 클래스라고 해서 반드시 추상 메서드를 가져야 되는 것은 아니다.
           하지만 추상 메서드를 가지면 반드시 추상클래스로 만들어야 된다.

       // 일반클래스, concrete 클래스 ( 어떤 기능처리를 할지 구체화되어 정해져 있는 클래스, 완성된 클래스 )
       public class 클래스명{
           
	    //구성요소 3가지
            변수
	    메서드 ( concrete 메서드: {} 가짐. {} 안에 실행되는 동작이 정해져 있음. )
	    생성자
       }

   2) 특징
      - 불완전 클래스이기 때문에 객체생성(new) 불가.
       직접적인 new 는 불가능하지만 다른 일반클래스(concrete 클래스) 도움을 받아서 인스턴스화 될 수 있다.
        
	  추상클래스 ( 부모타입 )
             | 
             |   <== 상속관계 ( extends 이용 )
	     |
	  일반클래스 ( 자식클래스에서 추상클래스를 구체화할 수 있다. )

        반드시 추상클래스에 있는 추상 메서드를 자식클래스에서 재정의(overrding) 해야 된다. (**************)
       

      예>    public abstract class  A{

                 public abstract void a(); //추상 메서드. {} 없기 때문에 무슨 기능인지 아직 미정.
            }

	    public class B extends A{

		@Override
		public void a(){}   // concrete 메서드, {} 있기 때문에 무슨 기능인지 결정됨.
	    }

	    A a  = new A(); // 에러, 객체생성 불가

            A a  = new B(); //  다형성 적용 가능

     - abstract 키워드 관련된 UML 표기법은  이탤릭체로 표현.
   
    3) 목적:
       
        부모의 특정 메서드를 자식들이 반드시 사용하도록 강제할 목적임.
	강제하면 자식들의 메서드를 동일한 이름으로 만들 수 있다. ( 통일성 부여해서 재사용성이 높아짐 )

	결과가 강제성이 부여되기 때문에 모든 자식들에서 공통적인 메서드로 사용할 수 있다. 
	또한 일반적인 상속의 장점도 자식들은 누릴 수 있다.


5. 인터페이스 (*****************, 매우 중요)

 1) 문법:

     public interface 인터페이스명{
        
	  //구성요소
          -상수
	  -추상메서드
	  -default메서드
          -static메서드
     }

     인터페이스명.java 파일로 저장됨.

 2) 구성요소
  
   - 상수:    
           int NUM =20; 지정하면
           자동으로 public static final 이 지정된다.
	   결국  public static final int NUM= 20;
	   접근은 인터페이스명.상수명 으로 한다. ( 예> 인터페이스명.NUM )

   - 추상메서드:    void a(); <=== default 접근지정자이고 abstract 없음.
              자동으로 public abstract 가 지정된다.
	      결국 public abstract void a(); 됨.
	      따라서 인터페이스의 추상메서드는 abstract 생략가능하고
	        모든 추상메서드의 접근지정자는 public 임.

   - default메서드:  
             문법:  public default  void  b(){}
	          동작은 일반적인 concrete 메서드처럼 실행된다.
		  따라서 new(객체생성)후에 사용 가능하다.
  
   - static 메서드:
             문법:  public static  void  c(){}
	         동작은 일반적인  static 메서드처럼 실행된다.
		  따라서 new(객체생성)없이 클래스명.static메서드 사용 가능하다.

  3) 특징
     - 불완전 객체이기 때문에 new ( 객체생성 ) 불가.
       직접적인 new 는 불가능하지만 다른 일반클래스(concrete 클래스) 도움을 받아서 인스턴스화 될 수 있다. 
      
      인터페이스 ( 준부모 타입)
         | 
         |   <== 구현관계 ( implements 이용 )
         |
      일반클래스

        반드시 인터페이스에 있는 추상 메서드를 자식클래스에서 재정의(overrding) 해야 된다. (**************)

     - 상속은 단일상속이고 
       구현은 다중구현이 가능하다.


          (추상)클래스 (부모, 큰타입)
            |
            | <== 삼각형실선, 상속관계, extends , 단일상속
	    |
	  클래스 (자식)

      인터페이스 인터페이스 ( 준부모 타입, 큰타입))
	 |     |
	 |     |     <== 삼각형 점선, 구현관계(준상속관계) ,implements 이용 , 다중구현
	 |     |
	 일반클래스

      - 인터페이스간에도 관계가 성립될 수 있다.

          인터페이스
            |
            |  <== 삼각형실선, 상속관계, extends , 다중상속
	    |
	  인터페이스

      - 다형성 적용이 가능하다.

         예>  A a = new A(); // 에러
	     A a  = new B(); // 다형성 가능

   4) 목적1
      - 하위 클래스에서 특정 메서드를 사용하도록 강제.
       예> 애완동물 관리 프로그램

                 Pet


       Cat    Dog    Bird   Bat



   4) 목적2 (*************)
      - 클래스들간에 연관관계(참조)일 때 의존성 감소 목적임.
        용어: tight coupling , loosely coupling(권장)

       예>  A -----------> B -------------> C

                            ------------->  D

			    ------------->  E


      TestMain --------> DBService ---------> OracleDAO
      main() 
                                   ---------> MySQLDAO 

     tight coupling: 접근 대상이 클래스이기 때문에 OracleDAO 에서 MySQLDAO 변경시
                     DBService 가 수정이 되어야 한다.
     
     loosely coupling: 접근 대상이 인터페이스이기 때문에 OracleDAO 에서 MySQLDAO 변경시
                       DBService 가 수정 안된다.
                       이때 인터페이스는 버퍼역할을 담당한다. ( 다형성 문법이 적용됨 )

/////////////////////////////////////////////////////////////////////////////////
10일차 리뷰

1. 클래스
   - 최소단위
   - 현실세계의 객체 개념에서 나옴(속성,동작)
   - 클래스의 구성요소 3가지 
      변수: 속성의 값 저장, 인스턴스 변수, 멤버변수
      메서드: 동작(변수 수정,조회,검증..), 멤버메서드, 인스턴스 메서드,
      생성자: 변수 초기화 
   - 반드시 객체 생성이 필요 ( new )
      클래스 변수 = new 클래스([값,..]);
      변수.멤버

   - 생성자 및 메서드는 여러개 지정 가능 ( 오버로딩 생성자/메서드)
     반드시 인자갯수,타입,순서는 달라야 된다.
     명시적으로 생성자를 지정하지 않으면 자동으로 기본생성자가 생성됨.(default 생성자)

   - this 키워드 ( 자신의 인스턴스 참조할 때 사용 )
     명시적으로 this 사용하는 경우 2가지
       this.name <=== 로컬변수와 인스턴스변수명이 동일할 때
       this([값,..]); <=== 다른 오버로딩생성자 호출할 때, 반드시 첫라인에서 호출해야 된다.

2. 상속 ( inheritance )

    - 같은 종류의 클래스가 여러개 작성된 경우
    예> Cat, Dog, Bird,.....

           Pet (부모)

      Cat  Dog  Bird .... (자식)
   
    - UML 표기법은 삼각선 실선 사용.
      자바코드는 extends 부모클래스 사용.
    - 단일 상속
    - 상속을 하면 부모의 멤버(인스턴스변수와 메서드)를 자식이 사용가능.
      단, private 멤버와 생성자는 상속이 안됨.
    - 자신보다 항상 부모를 먼저 생성한다.
      자식생성자 첫라인에서 부모 생성자를 호출하는 super() 자동삽입되는 메커니즘.
    - java.lang.Object 는 최상위 클래스로서 모든 클래스의 부모가 된다.
    - 부모의 메서드를 필요시 재정의할 수 있다. ( 오버라이딩 메서드 )
      단, 부모의 메서드명과 동일
         부모의 리터타입과 동일
	 부모의 메서드 파라미터와 동일
	 접근지정자는 같거나 확대(위로)만 가능
	 예외클래스는 같거나 축소(아래로)만 가능
      @Override 어노테이션을 지정해서 규칙위반시 컴파일에러를 발생시킴.


3. 추상클래스
   -목적: 부모의 특정 메서드를 자식에서 반드시 사용하도록 강제.
    방법: 추상메서드 이용해서 자식들이 반드시 재정의하도록 처리.
    문법:
        public abstract class 클래스명{
             변수
	     메서드
	     생성자
	     추상메서드 ( public abstract void a(); ) // abstract 생략불가
	}
    특징: 객체생성 불가
        자식을 통해서 인스턴스화 가능.
	 
	  추상클래스
             |  상속관계, 삼각선 실선, extends, 단일상속
             |
	  자식클래스

        다형성 적용 가능.

4. 인터페이스
   -목적: 부모의 특정 메서드를 자식에서 반드시 사용하도록 강제.
    방법: 추상메서드 이용해서 자식들이 반드시 재정의하도록 처리.
    문법:
        public interface 인터페이스명{
             상수
	     추상메서드 ( public abstract void a(); ) // abstract 생략가능, public abstract 자동지정됨.
	     default메서드 ( public default void b(){} )
	     static메서드  ( public static void c(){} )

	}
     특징: 객체생성 불가
          자식을 통해서 인스턴스화 가능.
	 
	  인터페이스명
             |  구현관계, 삼각선 점선, implements , 다중구현
             |
	  자식클래스

	 다형성 적용 가능.

     주요용도 2가지 (*****************)
       - 부모의 특정 메서드를 자식에서 반드시 사용하도록 강제.
       - 클래스들간의 의존성 감소(loosely coupling )
/////////////////////////////////////////////////////////////////////////
11일차

1. 중첩 클래스 ( nested class, inner class )
  
  용도: 
 
  1) 개념: 클래스내에 멤버(변수/메서드)처럼 또 다른 클래스를 지정할 수 있고
          클래스내에 있는 클래스를 중첩클래스라고 부른다.

  2) 종류 4가지 ( inner class가 Outer클래스내에 어느 위치에서 정의되었냐 )

      가. member inner 클래스 ( Outer클래스내에 멤버와 동일하게 정의 )
        
	   class Outer{
               int n;
	       public void a(){}
		
               class Inner{
                    
	       }//end Inner

	   }//end Outer

        특징: Outer의 private 도 접근이 가능.
	    Outer$Inner.class 형식으로 컴파일됨.
	    Inner 사용은 Outer에서도 가능하고 다른 클래스에서도 가능하다.

     나. local inner 클래스 ( Outer클래스내 메서드내의 로컬변수와 동일하게 정의 )

         class Outer{
               int n;
	       public void a(){
	           int x=10; //로컬변수
		   	
		   class Inner{
			    
		   }//end Inner
	       
	       }//end a
	

	   }//end Outer
	
	 특징: Outer의 private 도 접근이 가능.
	    Outer$Inner.class 형식으로 컴파일됨.
	    Inner 사용은 Outer에서만 가능하다.


    다. static inner 클래스 (  static 지정된 inner class로서 Outer클래스의 static 멤버처럼 동작 )
 
         class Outer{
               int n;
            static int n2;
	       public void a(){}
		
            static  class Inner{
                    
	       }//end Inner

	   }//end Outer

    특징:    Outer의 멤버(인스턴스변수) 접근 불가
	    Outer$Inner.class 형식으로 컴파일됨.
	    Inner 사용은 Outer.Inner 에서만 가능하다.

    라. 익명 클래스 ( anonymous class ,  interface와 같이 사용 ) (*********************)
     
2. 익명 클래스 ( anonymous class, 이름없는 클래스)(*********************)

   1) 용도: 인터페이스(interface) 사용시 익명클래스를 주로 사용한다.
   2) 문법:

         public interface Flyer{
            public abstract void fly();
	 }
         // 이름있는 클래스
	 public class Bird implments Flyer{

            public void fly(){}
	 }

	 main(){
           
	     // 이름있는 클래스
	     Flyer f = new Bird();
	     f.fly();

	     //익명 클래스
	     Flyer f2 = new Flyer(){
                public void fly(){}
	     };
	     f2.fly();

	 }

3. 람다표현식 ( lambda expression )(*********************)

  1)용도: 익명클래스의 축소(간략)된 표현식.
  2)등장배경:  자바에서는 클래스가 최소 단위이다.
            따라서 메서드만 필요해도 클래스를 무조건 만들어야 된다.
	    클래스 껍데기를 걷어내고 메서드에만 집중하자. ( 함수형 프로그래밍 개념이다.)


  3)람다표현식 문법 종류 4가지
   
     가. 파라미터없고 리턴없는 형식

     나. 파라미터있고 리턴없는 형식
     다. 파라미터없고 리턴있는 형식
     라. 파라미터있고 리턴있는 형식
  
 4) 반드시 단 하나의 추상메서드만 가진 인터페이스만 람다표현식을 사용할 수 있다.
   ==> 단일책임원칙 개발방법론에 기반함.
      이것은 객체하나에 하나의 기능만 추가해서 명확한 책임을 부여할 수 있음.

         @FunctionalInterface  <== 추상메서드가 2개이상이면 에러발생.
         public interface Flyer{
            public abstract void fly();
	   // public abstract void land();
	 }

 5) 문법: 

      변수 = (메서드파라미터) -> {};  ( 자바, 람다 표현식 ) 
      변수 = (메서드(함수)파라미터) => {};  ( 자바스크립트, arrow 표현식 )

 * 상속--> 인터페이스 --> 익명클래스 --> 람다표현식 ---> 함수형인터페이스( java.util.function 패키지)


4. 유틸리티 클래스
 
  - API 중에서 사용할 만한 클래스들 의미.

  1) java.lang.String 

     가. 생성방법

       //1. 리터럴 이용 ( 동일한 문자열인 경우에는 한번 만 생성됨 )
           String s = "hello";

       /2. new 이용 ( 동일한 문자열인 경우에도 매번 새롭게 생성됨, heap 메모리에 생성 )
	   String x = new String("hello");

     나. 메서드 종류

     다. 특징
        - String 은 한번 생성된 문자열은 변경이 안된다. 메서드를 적용하면 새로운 문자열이 생성된다.
	  따라서 문자열이 많이 수정되는 경우에는 String 사용을 지양하자. 대신 StringBuilder 클래스를 사용한다.
	- 리터럴 이용 방법으로 생성한 문자열은 동일한 문자열인 경우에는 한번 만 생성됨.

  2) java.lang.StringBuilder ( java.lang.StringBuffer 동일한 기능이고 thread-safe 함. )
      - StringBuilder 는 thread-unsafe 함.
     
      //////////////////////////////////////////
       * thread 특징
         - 병행처리
         - 특정 데이터및 코드를 여러 thread가 공유가능.
 
        thread-safe:  특정 스레드가 작업을 끝날때까지 기다려줌. ( synchronized 키워드 )
	              성능은 떨어짐.
        thread-unsafe : 스레드들이 병행작업으로 처리됨.
	              성능은 좋으나 특정 작업은 보장 안됨.
      /////////////////////////////////////////

      가. 생성방법
      나. 메서드 종류
      다. 특징
          한번 생성된 문자열이 변경된다. 따라서 문자열 가공이 많이 생기는 작업에 사용할 수 있다.
       
  3) 날짜 데이터

     가. java.util.Date
          a. 생성방법
	     Date d = new Date();
          b. 메서드 종류
	     대부분의 메서드가 deprecated 되어있음.
	     따라서 잘 사용하지 않음.
	     java.text.SimpleDateFormat 클래스 이용하면 날짜정보를 얻을수 있음.

     나. java.util.Calendar
           
	   a. 생성방법
            Calendar cal = Calendar.getInstance(); // new 사용안함.  싱글톤 디자인 패턴
           b. 메서드 종류
            cal.get(Calendar.YEAR)
	   c.  특징
	      월은 + 1 지정해야 된다.
	      cal.get(Calendar.MONTH) + 1
        
	////////////////////////////////////////////
         싱글톤 디자인 패턴
         개념: 프로그램중에 단 하나의 인스턴스만을 만들 때 사용.
	   예> 지구(Earth)

	     public class Earth{
              
	        private static Earth e;

		private Earth(){  // 외부에서 new Earth() 불가능.
                    // e = new Earth();
		}
		public static Earth getInstance(){
	             if(e==null){
                         e = new Earth();
		     }
		     return e;
	        }
	     }
	    // main 메서드
            Earth xxx = Earth.getInstance();
            Earth xxx2 = Earth.getInstance();

	    System.out.println(xxx == xxx2 ); // true
        ////////////////////////////////////////////////

     다. java.time.LocalDate (추천)


                //현재 날짜
		LocalDate today = LocalDate.now();
		System.out.println(today);  // 2024-11-18
		
		LocalDate today2 = today.minusDays(2);
		today2 = today.minusMonths(2);
		today2 = today.minusYears(2);
		System.out.println(today2);  // 2024-11-16
		
		LocalDate today3 = today.plusDays(2);
		today3 = today.plusMonths(2);
		today3 = today.plusYears(2);
		System.out.println(today3);  // 2024-11-20
		
		//특정날짜 설정-1
		LocalDate xxx = LocalDate.of(1999, 10, 12);
		System.out.println(xxx);  // 1999-10-12
		
		// str---> LocalDate
		// LocalDate parse(CharSequence text, DateTimeFormatter formatter)
		String str = "1999-10-12";
		LocalDate xxx2 = LocalDate.parse(str, DateTimeFormatter.ofPattern("yyyy-MM-dd"));
		System.out.println(xxx2);  // 1999-10-12
		
		String str2 = "1999년10월12일";
		LocalDate xxx3 = LocalDate.parse(str2, DateTimeFormatter.ofPattern("yyyy년MM월dd일"));
		System.out.println(xxx3);  // 1999-10-12
 

    4) java.util.StringTokenizer

       - 구분자를 가진 문자열에서 구분자를 이용해서 문자열을 분리할 때 사용
       - 구분자의 기본은 공백문자.

        예> "홍길동 이순신 유관순" 
	   "홍길동/이순신/유관순"

         String s2 = "홍길동/이순신/유관순";
	StringTokenizer st = new StringTokenizer(s2, "/");
	  while (st.hasMoreTokens()) {
		 System.out.println(st.nextToken());
	  }



     5) 랜덤값 얻기
       - java.util.Random

         Random ran = new Random();
	
	System.out.println("정수값:" + ran.nextInt());
	System.out.println("정수값(범위):" + ran.nextInt(3));  // 0~2
	
	System.out.println("실수값:" + ran.nextFloat());
	System.out.println("논리값:" + ran.nextBoolean());

      6) enum 타입(객체)
       
        - 여러 개의 상수를 효율적으로 사용하기 위한 객체이다.
	  일반적으로 switch 문에서 사용됨. ( enum에서 정의하지 않은 상수값은 switch문에서 사용하면 에러 발생됨 )
	- 문법:
	  
	    public enum  enum명{
                 상수1, 상수2, 상수3,...;  // 예> 요일
	    }

	    사용방법:  enum명.상수

	  예>  
	  public enum Day {
		SUNDAY,MONDAY,TUESDAY,
		WEDNESDAY,THURSDAY,FRIDAY,SATURDAY;
	 }

	  Day day = Day.MONDAY;
		
		switch (day) {
		case SUNDAY: System.out.println("SUN");break;

//////////////////////////////////////////////
12일차

1. 예외처리 ( exception handling )
 
  1) 예외 ( exception )
    - 일반적으로 에러(error)라고 불리움.
      프로그램 실행중에 발생되는 문제이다.
      발생되면 프로그램이 중단된다. 중단되서 예외가 발생된 코드 이후의 작업은 실행이 안됨. ( 비정상 종료 )

  2) 예외처리 ( exception handling )
    - 예외가 발생된 코드를 수정 및 재실행 하는 것이 아니고 
      발생된 코드 이후의 코드를 실행하도록 처리하는 작업이다. 
      결국 main 메서드 끝까지 실행되도록 처리하는 것이다. ( 정상 종료 )
      즉 비정상 종료되는 코드를  정상 종료되도록 처리하는 것이다. (**********)

  3) 예외처리 방법 

     - 예외 클래스 사용
     - 2가지 방법
      
       가.  try{

           }catch(예외클래스  변수){

	   }
    
       나.  throws 예외클래스

  4) 예외 클래스 ( 외우기 )
    
           Object
	     |
	   Throwable ( getMessage(), printStackTrace() )
	     |
 Error                                   Exception ( 예외클래스의 최상위 클래스)
                                            |
               (런타임계열, 실행시 발생되는 예외처리         (비 런타임계열, 컴파일시 발생되는 예외처리 클래스)
	        클래스)
	        RuntimeException                   IOException/SQLException
                 |                                    |
		ArrayIndexOutofBoundsException      FileNotFoundException
		( 배열 index 불일치 경우 )
		NullPointerException                ..
		( 객체생성없이 메서드 호출시)
		ArithmeticException
		( 0으로 나누었을 때 )
		ClassCastExcpetion
		( 형변환이 잘못된 경우 )
		...


2. 예외처리 방법 1 :  try~catch~finally + 예외클래스 

  문법:
       try{

	  문장1;
	  문장2;
	  문장3;
	  ..

       }catch( 예외클래스      변수 ){
        
	 예외발생시 처리문장; // 할수있는 최고의 처리는 예외정보를 출력하는 것이다.
  
       }

     - catch에 사용되는 예외클래스는 아무거나 사용안되고 적합한 예외클래스를 사용해야 된다.
      단 다형성을 적용하여 부모 예외클래스 사용은 가능하다.
      하지만 권장하지 않고 적합한 예외클래스 사용(디테일한)을 권장한다.

     - 예외가 발생된 곳에서 처리하는 방법임.

     - catch에서 처리한 예외클래스가 가진 예외정보를 사용할 수 있다.
       System.out.println( e.getMessage());
       e.printStackTrace();  // 개발자 디버깅용

     - 다중 catch 문 가능
        
	  try{

	  문장1; // ArithmeticException 발생가능성 코드
	  문장2;
	  문장3; // NullPointerException 발생가능성 코드
	  ..

       }catch( ArithmeticException      변수 ){
        
	 예외발생시 처리문장; // 할수있는 최고의 처리는 예외정보를 출력하는 것이다.
  
       }catch( NullPointerException      변수 ){
        
	 예외발생시 처리문장; // 할수있는 최고의 처리는 예외정보를 출력하는 것이다.
  
       }catch( Exception     변수 ){
        
	 예외발생시 처리문장; // 할수있는 최고의 처리는 예외정보를 출력하는 것이다.
  
       }
 
       반드시 예외클래스 계층구조에서 부모 예외클래스는 가장 나중에 catch로 지정해야 된다.

     - finally 문  ( 옵션 )
       
       예외발생 여부와 무관하게 반드시 수행되는 문장을 설정할 때 사용됨.

       try{
	  실행문장1;
          실행문장2;
	  ..
       }catch( ){
	  예외발생시 처리하는 문장	
       }catch( ){
          예외발생시 처리하는 문장	
       }finally{
          예외발생여부와 무관하게 항상 수행. ( 예> 외부자원 close 작업 )
       }

      * catch 없는 try~finally 문 가능
        목적은 예외처리 목적이 아님. 반드시 수행되는 문장이 어떤 문장인지를 알려주는 목적이 더 크다.

        try{

	}finally{
          반드시 수행되는 문장;
        }
       
 2. 예외처리 방법 2 :   throws 예외클래스
 
    - try~catch는 예외가 발생된 곳에서 처리하는 방법이고
      throws 는 예외가 발생된 곳이 아닌 다른 곳에서 예외처리하도록 위임하는 방법이다.
      위임하는 대상은 메서드를 호출한 곳으로 위임한다.
      결국 main메서드를 제외한 나머지 메서드는 throws 예외클래스 방식으로 예외처리를 하고
      main 에서는 try~catch로 최종 예외처리한다. ( try~catch문을 main에서 처리함으로써 예외처리를 집중화할 수 있음)

   문법:

    main(){       a()throws ArithmeticException{     b() throws ArithmeticException{
    try{
      a();         b();                               int result = 10/0;
     }catch(){

     }
    }             }                                  }
 

    - 다중 throws 가능
      문법:  throws ArithmeticException,NullPointerException,...{}

   
    - 오버라이딩(Overriding ) 메서드에서의 throws 문법 정리
      주의할 점은 RuntimeException 계열은 문법에서 무시한다.

      부모 메서드:       public void a() throws XXXException{}

      재정의 메서드:      접근지정자(같거나 위로) void a() throws(같거나 축소)
             
  3.  런타임 계열  vs  비런타임 계열
   
     가. 런타임 계열 ( 컴파일 언체크드 예외, compile unchecked 계열)
        - 명시적인 예외처리를 하지 않는다.
	  즉 throws 또는 try~catch를 사용하지 않는다.
	  런타임 계열은 예외가 발생되면 안되는 코드이다. ( 개발자가 잘못 코드를 구현한 것임 )
          if 문을 사용해서 예외가 발생되지 않도록 해야 된다.

     나. 비런타임 계열 ( 컴파일 체크드 예외, compile checked 계열 )
        - 반드시 명시적으로 예외처리를 해야 된다. (**********)
          즉 throws 또는 try~catch를 해야 된다.
	 예> DB 연동, 파일연동등.
 
  4. 명시적 예외 발생

   - 문법: if(조건) throw new XXXException("에러메시지"); <== 비정상 종료됨. 따라서 예외처리도 필요.
   - 용도:
        사용자가 만든 어플리케이션에서 특정 조건을 만족하지 않는 경우에 사용됨.
	예> Random 에서 랜덤값이 0이 나왔을때 ( 자바 입장에서는 예외가 아니지만 사용자 입장에서는 예외라고 할 수 있음 )

///////////////////////////////////
12일차 리뷰

1. 자바의 예외 종류

  1) 실행시 발생
     - 런타임 계열
     - 예외클래스: RuntimeException 및 하위 예외클래스 ( ArithmeticException, NullPointerException,...)
     - 특징: 원래는 발생되면 안되는 예외들이다. 
            발생시 예외처리 방법으로 처리하지 않고 if문으로 처리해야 되는 코드들이다.
     

  2) 컴파일시 발생
     - 비런타임 계열
     - 예외클래스: RuntimeException 제외한 Exception 및 하위 예외클래스(IOException,SQLException)
     - 특징: 반드시 예외처리(try~catch, throws )를 해야된다.

2. 예외클래스 계층구조

             Object
	        |
	    Throwable
	         |
	     Exception 
	         |
 RuntimeException  사용자정의예외클래스   IOException/SQLException 
  ...                    ..

3. 예외처리 방법 ( 모두 예외클래스 이용)

   1) 예외가 발생된 곳에서 처리
      try{
         문장1;
	 문장2;
	 ..
      }catch(예외클래스1 변수){
         예외 발생시 실행되는 문장;
      }catch(예외클래스2 변수){
         예외 발생시 실행되는 문장;
      }catch(Exception e){

      }

   2) 예외가 발생된 곳이 아닌 메서드를 호출한 곳에서 처리
      - throws 예외클래스1, 예외클래스2{}
      - main메서드를 제외한 모든 메서드는 throws 하고 
        최종적으로 main에서 try~catch로 예외처리한다.

4. finally 문
  
   - 반드시 실행되어야 하는 문장을 알려주는 용도임.
      try{
         문장1;
	 문장2;
	 ..
      }catch(예외클래스1 변수){
         예외 발생시 실행되는 문장;
      }finally{
         반드시 실행되어야 하는 문장;
      }

   - try~finally 문 가능
      try{
         문장1;
	 문장2;
	 ..
      }finally{
         반드시 실행되어야 하는 문장;
      }

5. 명시적 예외 발생

   - 자바 입장에서는 예외가 아니고 
     사용자 입장에서는 예외라고 간주할 수 있는 상황에서 사용됨.

   - 문법:
         if(조건식) throw new UserDefinedException("예외메시지"); <== 비정상종료됨. 예외처리 코드(throws)가 추가됨.

     예> Random에서 0 값이 나왔을때.
        DB에서 원하는 항목을 검색할 때 값이 없을 때.
   
     * throws 와 throw
      throws: 예외처리를 메서드를 호출한 곳으로 위임할 때.
      throw:   명시적 예외 발생시킬 때.


/////////////////////////////////////////////////
13일차
1.  사용자 정의 예외 클래스 (**************)

   예> 10/0 ==> ArithmeticException
      null값 ==> NullPointerException

      Random값
       0 일때  => 사용자 정의 예외클래스

  문법:  public class UserDefinedException extends Exception{
          // 인스턴스, 메서드 추가 가능
          public UserDefinedException(String mesg){
		super(mesg);
	  }
       }


2. 제네릭스 ( generics )

  1) 개념
    다양한 데이터 타입을 다루는 메서드 및 클래스에서
    컴파일 시점(*****)에 데이터의 타입을 체크해서 예외를 미리 알 수 있도록 지원하는 기능.

  2) 제네릭스 표현
   
    <T>: reference Type 의미
    <E>: Element 의미
    <K,V>: Key, Value 의미

  3) 장점
    - 저장하는 데이터 타입체크를 컴파일 시점에서 처리하기 때문에 타입 안전성 확보가능( 저장하는 데이터타입을 제한 가능 )
    - 값을 가져올 때 형변환이 불필요함.

  4) 특징
    - <T>는 컴파일 시점에 실제 지정된 데이터 타입으로 변환됨.
    - 클래스, 인터페이스, 메서드 파라미터 및 리턴타입에 사용한다.

  5) 메서드파라미터로 제네릭 타입 전달시 제약 설정 방법
   class Person{}
   class Man extends Person{}
   class Woman extends Person{}


   printData(List<?> list): 제네릭된 모든 타입이 전달 가능.
   printData2(List<? extends Person> list) : 제네릭된 Person 또는 Person의 자식들(Man,Woman)만 전달 가능
   printData3(List<? super Man> list) : 제네릭된 Man 또는 Man의 부모인 Person 만 전달 가능.


3. 컬렉션 API
 
  1) 데이터 저장 방법 3가지
    가. 변수
    나. 배열
        - 크기변경이 불가
	- 동일한 데이터만 저장 가능.
	- 배열에서 사용가능한 메서드가 없음. ( 지원되는 메서드가 없음)
	  하지만 Arrays 유틸리티 클래스에서 배열관련 메서드를 지원한다.

    다. 컬렉션 API ( 자료구조 )
        - 크기변경이 가능
	- 다른 데이터 저장도 가능
	- 자체적으로 사용 가능한 메서드가 지원됨.
	  또한 Collections 유틸리티 클래스에서 추가 메서드를 지원한다.
 
  2)  컬렉션 API 종류 3가지 ( 외우기 )
  
   - java.util 패키지

    가. List 계열
        - 저장되는 데이터의 순서가 존재한다. ( 내부적으로 idx 이용함 )
	- 중복 데이터 저장이 가능하다.
	- 필요시 idx 이용해서 값을 얻는다.
        - 실제 사용하는 클래스는 ArrayList.

    나. Set 계열
	- 저장되는 데이터 순서가 없다. 
	- 중복 데이터 저장이 불가 ( 중복데이터 저장시 한번만 저장됨 )
        - 필요시 모든 값을 얻는다.
        - 실제 사용하는 클래스는 HashSet.
    다. Map 계열
       - key(name)와 value 쌍으로 저장. 저장되는 데이터 순서가 없다.
         필요시 key이용해서 value 값을 얻는다.
	 가장 빠르게 데이터 조회가 가능하다.
       - 실제 사용하는 클래스는 HashMap.

  3)  컬렉션 API 계층구조 ( 외우기 )

           Collection<E> (인터페이스) - add(E e)-추가,clear()
                |                   contains(Object obj)
			            remove(Object obj),size()
				    iterator():Iterator<E>
                |
  Set<E>(인터페이스)     List<E>(인터페이스)
    | of(값...)                | add(int index, E element)-삽입
                                 get(int index), of(값...),remove(int index)
				 set(int index, E element)-수정,sort(), subList()
    |                          |
 HashSet<E>(클래스)    ArrayList(클래스, thread-unsafe), Vector(클래스, thread-safe)
                           indexOf(Object o)

 ////////////////////////////////////////////////////////////////////////////////
      Map<K,V> (인터페이스) <= Collection 인터페이스와 무관.
         |       clear(), containsKey(Object key),containsValue(Object value)
	         get(Object key), keySet()-키값만조회, of(k,v)
		 put(K key, V value)-저장, remove(Object key),replace(K key, V value)
		 size(), values()
	 |
     HashMap(클래스)

   * 값의 크기 
    1) 배열크기 : 배열명.length
    2) 문자열크기(길이): str.length()
    3) 컬렉션크기     : x.size()

///////////////////////////////////////////
 * Iterator 와 Enumeration
 - 기능은 Collection ( ArrayList, HashSet, Vector )에 저장되어 있는 데이터를
 반복해서 얻을 때 사용한다.

   가. Iterator
     - ArrayList와 HashSet, Vector 에서 모두 사용
	
	예>  Iterator<String> ite = list.iterator();
	    while(ite.hasNext()){
               System.out.println(ite.next());
	    }

   나. Enumeration
      Vector 에서만  사용

       예> Enumeration<String> enu = v.elements();
          while(enu.hasMoreElements()){
             System.out.println(ite.nextElement());
	  }
         

//////////////////////////////////////////
4.  Arrays 와 Collections 유틸리티 


    가. java.util.Arrays 
      
       - 배열시 사용시 유용한 메서드 제공

    나. java.util.Collections
     
       - 컬렉션(List) 사용시 유용한 메서드 제공

////////////////////////////////////////////////////
13 일차

1. 표준 API 함수적 인터페이스(추상메서드 관련)

  1) 개념
    - 메서드의 종류가 4가지
     가. 파라미터 없고 리턴없는 형식 (  X )
     나. 파라미터 있고 리턴없는 형식 ( Consumer )
     다. 파라미터 없고 리턴있는 형식 ( Supplier )
     라. 파라미터 있고 리턴있는 형식 ( Function )
   현재까지는 위 기능을 하는 메서드가 필요하다면 인터페이스를 만들어서
   메서드를 구현했음.
   매우 많이 사용되는 형식이기 때문에 API 에서 위 종류의 추상메서드를
   가진 인터페이스를 제공해줌.
   이 인터페이스를 표준 API 함수적 인터페이스라고 부른다.
   이 인터페이스는 이름있는 클래스, 익명클래스, 람다표현식이 모두 가능하다.
  
  2) java.util.function 패키지 

   @FunctionalInterface <== 반드시 단 하나의 추상메서드만 가지도록 강제한다.
    Consumer<T> : 파라미터 있고 리턴없는 형식
                 추상메서드: void accept(T t)

               하위: BiConsumer<T,U> : void accept(T t, U u)
	           DoubleConsumer   :void accept(double value)
		   IntConsumer      : void accept(int value)
		   LongConsumer     : void accept(long value)
                   ObjDoubleConsumer<T> : void accept(T t, double value)
		   ObjIntConsumer<T>   : void accept(T t, int value)
		   ObjLongConsumer<T>  : void accept(T t, long value)


   Supplier<T> : 파라미터 없고 리턴있는 형식  
                 추상메서드: T get()

               하위: BooleanSupplier : boolean getAsBoolean()
	           DoubleSupplier   : double getAsDouble()
		   IntSupplier      : int getAsInt()
		   LongSupplier     : long getAsLong()

   @FunctionalInterface
   Function<T,R> :  파라미터 있고 리턴있는 형식 (***********)
               
	        추상메서드: R apply(T t)
	       
                하위: BiFunction<T,U,R> : R apply(T t, U u)
		     DoubleFunction<R> : R apply(double value)
		     IntFunction<R>    : R apply(int value)
		     LongFunction<R>    : R apply(long value)
		     DoubleToIntFunction : int applyAsInt(double value)
		     DoubleToLongFunction : long applyAsLong(double value)
		     IntToDoubleFunction  : double applyAsDouble(int value)
		     IntToLongFunction    : long applyAsLong(int value)
		     LongToDoubleFunction : double applyAsDouble(long value)
		     LongToIntFunction    : int applyAsInt(long value)
		     ToDoubleBiFunction<T,U> : double applyAsDouble(T t, U u)
		     ToDoubleFunction<T> : double applyAsDouble(T value)
		     ToIntBiFunction<T,U> : int applyAsInt(T t, U u)
		     ToIntFunction<T>     : int applyAsInt(T value)
		     ToLongBiFunction<T,U>  : long applyAsLong(T t, U u)
		     ToLongFunction<T>   : long applyAsLong(T value)

  Operator    :  파라미터 있고 리턴있는 형식,
                 Function 을 상속받음.
		 Function과 차이점은 Function은 파라미터타입과 리턴타입을 사용자가 임의로 설정이 가능함.
		 즉 파라미터타입과 리턴타입이 서로 다른 타입이어도 가능했음.
                 
		 Operator 는 파라미터타입과 리턴타입이 서로 같음.
		 따라서 파라미터타입과 명시하도록 되어 있음.

                하위: BinaryOperator<T> : T apply(T t, T u)
		    UnaryOperator<T>  : T apply(T t)
		    DoubleBinaryOperator : double applyAsDouble(double left, double right)
		    DoubleUnaryOperator : double applyAsDouble(double operand)
		    IntBinaryOperator   : int applyAsInt(int left, int right)
		    IntUnaryOperator    : int applyAsInt(int operand)
		    LongBinaryOperator : long applyAsLong(long left, long right)
		    LongUnaryOperator : long applyAsLong(long operand)